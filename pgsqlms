#!/bin/bash

#   Resource Agent for managing foobar resources.
#
#   License:      PostgreSQL License (BSD Like)
#   (c) 2012-2013 Jehan-Guillaume de Rorthais, Maël Rimbault

# Initialization
: ${OCF_FUNCTIONS_DIR=${OCF_ROOT}/lib/heartbeat}
. ${OCF_FUNCTIONS_DIR}/ocf-shellfuncs

# Default parameters
OCF_RESKEY_system_user_default="postgres"
OCF_RESKEY_bindir_default="/usr/bin"
OCF_RESKEY_pgdata_default="/var/lib/pgsql/data"
OCF_RESKEY_pgport_default=5432
OCF_RESKEY_pghost_default="/tmp"

: ${OCF_RESKEY_system_user=${OCF_RESKEY_system_user_default}}
: ${OCF_RESKEY_bindir=${OCF_RESKEY_bindir_default}}
: ${OCF_RESKEY_pgdata=${OCF_RESKEY_pgdata_default}}
: ${OCF_RESKEY_pgport=${OCF_RESKEY_pgport_default}}
: ${OCF_RESKEY_pghost=${OCF_RESKEY_pghost_default}}
: ${OCF_RESKEY_service=${OCF_RESKEY_service_default}}
: ${OCF_RESKEY_recovery_template=${OCF_RESKEY_pgdata}/recovery.conf.pcmk}

# this script expect english output, not random translations depending on
# the system config
export LANG="C"

# PostgreSQL commands path
export PGCTL="${OCF_RESKEY_bindir}/pg_ctl"
export PGPSQL="${OCF_RESKEY_bindir}/psql"
export PGCTRLDATA="${OCF_RESKEY_bindir}/pg_controldata"
export PGISREADY="${OCF_RESKEY_bindir}/pg_isready"
export CRM_MASTER="${HA_SBIN_DIR}/crm_master -l reboot"
export CRM_ATTRIBUTE="${HA_SBIN_DIR}/crm_attribute -l reboot"
export NODENAME=$(ocf_local_nodename)

current_action="$1"

function pgsql_validate_all() {
    local rc
    local PGVERSION

    # check binaries
    check_binary "$PGCTL"
    check_binary "$PGPSQL"
    check_binary "$PGCTRLDATA"
    check_binary "$PGISREADY"
    check_binary "${HA_SBIN_DIR}/crm_master"
    check_binary "cp"
    check_binary "sed"
    check_binary "grep"

    # check pgdata
    if [ ! -d "${OCF_RESKEY_pgdata}" ] ; then
        ocf_log error "PGDATA \"${OCF_RESKEY_pgdata}\" doesn't exist";
        return $OCF_ERR_CONFIGURED
    fi

    # check pgdata
    if [ ! -s "${OCF_RESKEY_pgdata}/PG_VERSION" ] ; then
        ocf_log error "PG_VERSION does not exists in \"${OCF_RESKEY_pgdata}\"";
        return $OCF_ERR_CONFIGURED
    fi

    # check recovery template
    if [ ! -f "${OCF_RESKEY_recovery_template}" ] ; then
        ocf_log error "Recovery template '${OCF_RESKEY_recovery_template}' does not exists";
        return $OCF_ERR_CONFIGURED
    fi

    # check system user
    id -nu "${OCF_RESKEY_system_user}" > /dev/null 2>&1
    rc=$?
    if [ ! $rc ] ; then
        ocf_log error "System user \"${OCF_RESKEY_system_user}\" doesn't exist";
        return $OCF_ERR_CONFIGURED
    fi

    # require 9.3 minimum
    PGVERSION="$(cat ${OCF_RESKEY_pgdata}/PG_VERSION)"
    PGVERNUM=$(( ${PGVERSION%.*} * 10000 + ${PGVERSION#*.} * 100 ))
    if [ $PGVERNUM -lt 90300 ] ; then
        ocf_log error "PostgreSQL version $PGVERSION not supported. Require 9.3 and more.";
        return $OCF_ERR_CONFIGURED
    fi

}

ocf_meta_data() {
    cat <<EOF
<?xml version="1.0"?>
<!DOCTYPE resource-agent SYSTEM "ra-api-1.dtd">
<resource-agent name="pgsqlsr">
  <version>1.0</version>

  <longdesc lang="en">
    Resource script for PostgreSQL in replication. It manages PostgreSQL servers using streaming replication as an HA resource.
  </longdesc>
  <shortdesc lang="en">Manages PostgreSQL servers in replication</shortdesc>
  <parameters>
    <parameter name="system_user" unique="0" required="0">
      <longdesc lang="en">
        System user account used to run the PostgreSQL server
      </longdesc>
      <shortdesc lang="en">PostgreSQL system User</shortdesc>
      <content type="string" default="${OCF_RESKEY_system_user_default}" />
    </parameter>

    <parameter name="bindir" unique="0" required="0">
      <longdesc lang="en">
        Path to the directory storing the PostgreSQL binaries. The agent uses pg_controldata and pg_ctl.
      </longdesc>
      <shortdesc lang="en">Path to the PostgreSQL binaries</shortdesc>
      <content type="string" default="${OCF_RESKEY_bindir_default}" />
    </parameter>

    <parameter name="pgdata" unique="1" required="0">
      <longdesc lang="en">
        Path to the data directory, e.g. PGDATA
      </longdesc>
      <shortdesc lang="en">Path to the data directory</shortdesc>
      <content type="string" default="${OCF_RESKEY_pgdata_default}" />
    </parameter>

    <parameter name="pghost" unique="0" required="0">
      <longdesc lang="en">
        Host IP address or unix socket folder the instance is listening on.
      </longdesc>
      <shortdesc lang="en">Instance IP or unix socket folder</shortdesc>
      <content type="string" default="${OCF_RESKEY_pghost_default}" />
    </parameter>

    <parameter name="pgport" unique="0" required="0">
      <longdesc lang="en">
        Port the instance is listening on.
      </longdesc>
      <shortdesc lang="en">Instance port</shortdesc>
      <content type="integer" default="${OCF_RESKEY_pgport_default}" />
    </parameter>

    <parameter name="recovery_template" unique="1" required="0">
      <longdesc lang="en">
        Path to the recovery.conf template. This file is simply copied to $PGDATA
        before starting the instance as slave
      </longdesc>
      <shortdesc lang="en">Path to the recovery.conf template.</shortdesc>
      <content type="string" default="${OCF_RESKEY_pgdata_template}/recovery.conf.pcmk" />
    </parameter>

    <parameter name="last_lsn" unique="0" required="0">
      <longdesc lang="en">
        FIXME: DON'T TOUCH THIS
      </longdesc>
      <shortdesc lang="en">FIXME: DON'T TOUCH THIS</shortdesc>
      <content type="string" default="0" />
    </parameter>

  </parameters>
  <actions>
    <action name="start" timeout="120" />
    <action name="stop" timeout="120" />
    <action name="status" timeout="60" />
    <action name="reload" timeout="60" />
    <action name="promote" timeout="60" />
    <action name="demote" timeout="120" />
    <action name="monitor" depth="0" timeout="30" interval="30"/>
    <action name="notify" timeout="60" />
    <action name="meta-data" timeout="5" />
    <action name="validate-all" timeout="5" />
    <action name="methods" timeout="5" />
  </actions>
</resource-agent>
EOF
}

ocf_methods() {
    # FIXME: ajouter methodes
    cat <<EOF
        start
        stop
        status
        reload
        promote
        demote
        monitor
        notify
        methods
        meta-data
        validate-all
EOF
}

# Execute command passed as argument with system user
# 
_runuser() {
    local rc

    runuser -l -c "LANG=$LANG $1" "${OCF_RESKEY_system_user}"
    rc=$?

    return $rc
}

# Check if instance is listening on the given host/port
#
_pg_isready() {
    local rc
    local msg

    msg=$($PGISREADY -h "${OCF_RESKEY_pghost}" -p "${OCF_RESKEY_pgport}")
    rc=$?

    ocf_log debug "$__OCF_ACTION - _pg_isready: $msg."

    # possible error codes:
    #   1: ping rejected (usually when instance is in startup, in crash
    #      recovery , in warm standby or a shutdown is in progress)
    #   2: no response, usually means the instance is down
    #   3: no attempt, probably a syntax error, should not happen
    return $rc
}

# Check the postmaster.pid file and the postmaster process.
# WARNING: we do not distinct the scenario where postmaster.pid does not exists
# and the process is still alive. It should be ok though, as this is considered
# as a hard error from monitor.
_pg_ctl_status() {
    local rc

    _runuser "$PGCTL -D ${OCF_RESKEY_pgdata} status &> /dev/null"
    rc=$?

    # possible error codes:
    #   3: postmaster.pid file does not exists OR it does but the process 
    #      with the pid found in the file is not alive
    return $rc
}

_controldata_state() {
    "$PGCTRLDATA" "${OCF_RESKEY_pgdata}" 2>/dev/null | \
        sed -rn 's/^Database cluster state:\s+(.*)/\1/p' 2>/dev/null
}

# Use pg_controldata to check if the state of the PostgreSQL server. This 
# function return codes depending on this state, so we can find wether the 
# instance is Primary or Secondary, or use it to detect any inconsistency
# that could indicate the instance has crashed.
#
_controldata() {
    local CMD
    local inststate

    inststate=$(_controldata_state)

    while [ "$inststate" ]; do
        case $inststate in
            "in production")
                # Instance should be running as a Primary.
                ocf_log debug "$__OCF_ACTION - _controldata: instance $OCF_RESOURCE_INSTANCE state is \"$inststate\"."
                return $OCF_RUNNING_MASTER
                ;;
            "in archive recovery")
                # Instance should be running as a Secondary.
                # This state includes Warm Standby (rejects connections
                # attempts, including pg_isready)
                ocf_log debug "$__OCF_ACTION - _controldata: instance $OCF_RESOURCE_INSTANCE state is \"$inststate\"."
                return $OCF_SUCCESS
                ;;
            "shut down"|"shut down in recovery")
                # The instance should be stopped.
                # We don't care if it was Primary or Secondary before, because
                # we always start instances as Secondaries, and then promotes
                # if necessary.
                ocf_log debug "$__OCF_ACTION - _controldata: instance $OCF_RESOURCE_INSTANCE state is \"$inststate\"."
                return $OCF_NOT_RUNNING
                ;;
            *)
                # The state is "in crash recovery", "starting up" or 
                # "shutting down".
                # This state should be transitional, so we wait and loop to 
                # check if it changes.
                ocf_log debug "$__OCF_ACTION - _controldata: instance $OCF_RESOURCE_INSTANCE state is \"$inststate\": waiting."
                sleep 1
                inststate=$(_controldata_state)
                ;;
        esac
    done

    # If we reach this point, something went wrong with pg_controldata
    # FIXME: better to raise a hard error at this point, like OCF_ERR_CONFIGURED ?
    ocf_log error "$__OCF_ACTION - _controldata: unable get instance $OCF_RESOURCE_INSTANCE state using pg_controldata."
    ocf_log debug "$__OCF_ACTION - _controldata: instance $OCF_RESOURCE_INSTANCE state is \"$instance_state\"."
    return $OCF_ERR_GENERIC

}

# Run a query using psql
#
_query() {
    local rc
    local ANS
    local QUERY="$1"
    local connection_string="port=${OCF_RESKEY_pgport} dbname=postgres $2"


    ANS=$(_runuser "
$PGPSQL -XAt --set='ON_ERROR_STOP=1' '$connection_string' <<EOQ
$QUERY
EOQ
" 2>/dev/null)
    rc=$?

    echo "$ANS"

    # possible error codes:
    #   1: failed to get resources (memory, missing file, ...)
    #   2: unable to connect
    #   3: query failed
    return $rc
}

# Checks to confirm if the instance is really started if _pg_isready returned
# it should be the case, and to identify whether the instance is Primary or 
# Secondary
#
_confirm_started() {
    local is_in_recovery
    local query_rc
    local controldata_rc

    if [ $OCF_CHECK_LEVEL -ge 10 ]; then
        # Hard check, call psql and pg_is_in_recovery()
        is_in_recovery=$(_query "SELECT pg_is_in_recovery()")
        query_rc=$?

        if [ $query_rc -eq 0 ]; then
            # The query was executed, check the result
            if [ "$is_in_recovery" = "t" ]; then
                # The instance is a Secondary.
                ocf_log debug "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): instance $OCF_RESOURCE_INSTANCE is a Secondary."
                return $OCF_SUCCESS
            elif [ "$is_in_recovery" = "f" ]; then
                # The instance is a Primary.
                ocf_log debug "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): instance $OCF_RESOURCE_INSTANCE is a Primary."
                return $OCF_RUNNING_MASTER
            fi
            # This should not happen, raise a hard configuration error.
            ocf_log error "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): the query used to check if instance $OCF_RESOURCE_INSTANCE is a Primary or a Secondary sent an unexpected result: \"$is_in_recovery\" !"
            return $OCF_ERR_CONFIGURED
        elif [ $query_rc -eq 1 -o $query_rc -eq 2 ]; then
            # psql cound not connect to the instance
            # FIXME raise an hard error here ?
            ocf_log error "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): psql could not connect to instance $OCF_RESOURCE_INSTANCE !"
            return $OCF_ERR_GENERIC
        elif [ $query_rc -eq 3 ]; then
            # The query failed.
            # This should not happen, raise a hard configuration error.
            ocf_log error "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): the query used to check if instance $OCF_RESOURCE_INSTANCE is a Primary or a Secondary failed !"
            return $OCF_ERR_CONFIGURED
        fi
    fi

    # Soft check, call pg_controldata to check wether Primary or Secondary
    _controldata
    controldata_rc=$?
    if [ $controldata_rc -eq $OCF_NOT_RUNNING ]; then
        # Something went wrong, the instance should not be listening if not
        # running !
        # FIXME raise an hard error here ?
        ocf_log error "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): instance $OCF_RESOURCE_INSTANCE controldata shows that instance is not running, but the instance is listening on local socket !"
        return $OCF_ERR_GENERIC
    elif [ $controldata_rc -eq $OCF_RUNNING_MASTER ]; then
        # The running instance is a Primary
        ocf_log debug "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): instance $OCF_RESOURCE_INSTANCE is a Primary."
        return $OCF_RUNNING_MASTER
    elif [ $controldata_rc -eq $OCF_SUCCESS ]; then
        # The running instance is a Secondary
        ocf_log debug "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): instance $OCF_RESOURCE_INSTANCE is a Secondary."
        return $OCF_SUCCESS
    fi

    # We should not get here, something went wrong
    ocf_log error "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): could not get instance $OCF_RESOURCE_INSTANCE status from controldata (returned: $controldata_rc) !"
    return $controldata_rc

}

# Checks to confirm if the instance is really stopped if _pg_isready returned
# it should be the case, and if it was propertly shut down.
#
_confirm_stopped() {
    local pgctlstatus_rc
    local controldata_rc

    _pg_ctl_status
    pgctlstatus_rc=$?

    if [ $pgctlstatus_rc -eq 0 ]; then
        # The pid file exists and the process is available
        # That should not be the case, return an error
        # FIXME raise an hard error at this point ?
        ocf_log error "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): instance $OCF_RESOURCE_INSTANCE is not listening, but the process referenced in postmaster.pid exists !"
        return $OCF_ERR_GENERIC
    else
        # The pid file does not exists or the process is not available
        ocf_log debug "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): no postmaster process found for instance $OCF_RESOURCE_INSTANCE"

        if [ -f "${OCF_RESKEY_pgdata}/backup_label" ]; then
            # We are probably on a freshly built standby that never start yet.
            ocf_log debug "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): backup_label file exists: probably on a never started standby."
            return $OCF_NOT_RUNNING
        fi

        # Continue the check with pg_controldata
        _controldata
        controldata_rc=$?
        if [ $controldata_rc -eq $OCF_RUNNING_MASTER ]; then
            # The controldata has not been updated to "shutdown"
            # It should mean we had a crash on a Primary instance
            ocf_log error "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): instance $OCF_RESOURCE_INSTANCE controldata indicates a running Primary instance, the instance has probably crashed !"
            return $OCF_FAILED_MASTER
        elif [ $controldata_rc -eq $OCF_SUCCESS ]; then
            # The controldata has not been updated to "shutdown in recovery"
            # It should mean we had a crash on a Secondary instance
            # There is no "FAILED_SLAVE" return code, so we return a 
            # generic error
            ocf_log error "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): instance $OCF_RESOURCE_INSTANCE controldata indicates a running Secondary instance, the instance has probably crashed !"
            return $OCF_ERR_GENERIC
        elif [ $controldata_rc -eq $OCF_NOT_RUNNING ]; then
            # The controldata state is consistent, the instance was
            # probably propertly shut down.
            ocf_log debug "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): instance $OCF_RESOURCE_INSTANCE controldata indicates that the instance was propertly shut down."
            return $OCF_NOT_RUNNING
        else
            # Something went wrong with the controldata check.
            ocf_log error "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): could not get instance $OCF_RESOURCE_INSTANCE status from controldata (returned: $controldata_rc) !"
            return $controldata_rc
        fi
    fi

}

# Start the PostgreSQL instance as a *slave*
pg_start() {
    local rc
    OCF_CHECK_LEVEL=20

    # instance must be running as slave or being stopped
    # anything else is an error
    pg_monitor
    rc=$?
    if [ $rc -eq $OCF_SUCCESS ]; then
        ocf_log info "$__OCF_ACTION - pg_start: instance $OCF_RESOURCE_INSTANCE already started."
        return $OCF_SUCCESS
    elif [ $rc -ne $OCF_NOT_RUNNING ] ; then
        ocf_log error "$__OCF_ACTION - pg_start: unexpected state for instance $OCF_RESOURCE_INSTANCE (returned $rc)."
        return $OCF_ERR_GENERIC
    fi

    #
    # From here, the instance is NOT running for sure
    #

    # create the recovery.conf file to start as a standby
    # NOTE: the recovery.conf is supposed to be set up so the standby can
    # connect to the instance in production. As there is no instance in
    # production on start, standbys will bail about failing to connect to
    # the primary.
    # As we can not reload a recovery.conf file on a standby without restarting
    # it, we will leave with this.
    cp -f "${OCF_RESKEY_recovery_template}" "${OCF_RESKEY_pgdata}/recovery.conf"
    rc=$?
    chown "${OCF_RESKEY_system_user}": "${OCF_RESKEY_pgdata}/recovery.conf"
    rc=$((rc + $?))
    chmod 0644 "${OCF_RESKEY_pgdata}/recovery.conf"
    rc=$((rc + $?))

    if [ $rc -ne 0 ]; then
        return $OCF_ERR_GENERIC
    fi

    _runuser "$PGCTL -D ${OCF_RESKEY_pgdata} -w start &>/dev/null"
    rc=$?

    # wait for the start to finish
    if [ $rc -eq 0 ]; then
        pg_monitor
        rc=$?
        while [ $rc -eq $OCF_NOT_RUNNING ]
        do
            sleep 1
            pg_monitor
            rc=$?
        done

        if [ $rc -eq $OCF_SUCCESS ]; then
            ocf_log info  "$__OCF_ACTION - pg_start: instance $OCF_RESOURCE_INSTANCE started."

            if [ "$current_action" == "start" ]; then
                # set master score to 1 so the node can be promoted
                ocf_log debug "$__OCF_ACTION - pg_start: instance started as a secondary, set master score to 1."
                $CRM_MASTER -v 1
            fi
        else
            ocf_log error "$__OCF_ACTION - pg_start: instance $OCF_RESOURCE_INSTANCE is not running as a slave (returned $rc)."
        fi

        return $rc
    fi

    ocf_log error "$__OCF_ACTION - pg_start: instance $OCF_RESOURCE_INSTANCE failed to start."
    return $OCF_ERR_GENERIC
}

# Stop the PostgreSQL instance
pg_stop() {
    local rc
    local state
    local PIDFILE="${OCF_RESKEY_pgdata}/postmaster.pid"
    OCF_CHECK_LEVEL=20

    # instance must be running as slave or master or being stopped
    # anything else is an error
    pg_monitor
    rc=$?
    if [ $rc -eq $OCF_NOT_RUNNING ] ; then
        ocf_log info "$__OCF_ACTION - pg_stop: instance $OCF_RESOURCE_INSTANCE already stopped."
        return $OCF_SUCCESS
    elif [ $rc -ne $OCF_SUCCESS -a $rc -ne $OCF_RUNNING_MASTER ]; then
        ocf_log warn "$__OCF_ACTION - pg_stop: unexpected state for instance $OCF_RESOURCE_INSTANCE (returned $rc)."
    fi

    #
    # From here, the instance is running for sure
    #

    _controldata
    state=$?

    # try to quit with proper shutdown
    #FIXME we should add a timeout in pg_ctl call, and try an immediate stop 
    # after that
    _runuser "$PGCTL -D ${OCF_RESKEY_pgdata} -w -m fast stop &>/dev/null"
    rc=$?

    if [ $rc -eq 1 -a ! -f "$PIDFILE" -a state -eq $OCF_NOT_RUNNING ]; then
        return $OCF_SUCCESS
    fi

    # wait for the stop to finish
    if [ $rc -eq 0 ]; then
        pg_monitor
        rc=$?
        while [ $rc -ne $OCF_NOT_RUNNING ]
        do
        #FIXME if proper shutdown does not cut it we need to use immediate stop
        # after some time, and avoid FAILED pacemaker state, which would 
        # trigger fencing
            sleep 1
            pg_monitor
            rc=$?
        done

        ocf_log info  "$__OCF_ACTION - pg_stop: instance $OCF_RESOURCE_INSTANCE stopped."
        return $OCF_SUCCESS
    fi

    ocf_log error "$__OCF_ACTION - pg_stop: instance $OCF_RESOURCE_INSTANCE failed to stop."
    return $OCF_ERR_GENERIC

}

# Monitor the PostgreSQL instance
pg_monitor() {
    local pgisready_rc
    local controldata_rc

    if ocf_is_probe; then
        ocf_log debug "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): monitor is a probe."
    fi

    # First check, verify if the instance is listening
    _pg_isready
    pgisready_rc=$?

    if [ $pgisready_rc -eq 0 ]; then
        # The instance is listening
        # We confirm that the instance is up and get if it is a Primary or a
        # Secondary using pg_controldata (OCF_CHECK_LEVEL < 10) or psql and 
        # pg_is_in_recovery() (OCF_CHECK_LEVEL >= 10).
        ocf_log debug "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): instance $OCF_RESOURCE_INSTANCE is listening."
        _confirm_started
        return $?

    elif [ $pgisready_rc -eq 1 ]; then
        # The attempt was rejected.
        # This could happen in several cases:
        #   - at startup
        #   - during shutdown
        #   - during crash recovery
        #   - if instance is a warm standby
        # Except for the Warm standby case, this should be a transitional state
        # We try to confirm using pg_controldata
        ocf_log debug "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): instance $OCF_RESOURCE_INSTANCE rejects connections - we check again."
        _controldata
        controldata_rc=$?
        if [ $controldata_rc -eq $OCF_RUNNING_MASTER -o $controldata_rc -eq $OCF_SUCCESS]; then
            # This state indicates that pg_isready check should succeed
            # We check again
            ocf_log debug "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): instance $OCF_RESOURCE_INSTANCE controldata shows a running status."
            _pg_isready
            pgisready_rc=$?
            if [ $pgisready_rc -eq 0 ]; then
                # Consistent with pg_controdata output
                # We can check if the instance is Primary or Secondary using 
                # pg_controldata (OCF_CHECK_LEVEL < 10) or psql and 
                # pg_is_in_recovery() (OCF_CHECK_LEVEL >= 10).
                ocf_log debug "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): instance $OCF_RESOURCE_INSTANCE is listening."
                _confirm_started
                return $?

            else
                # Still not consistent, raise an error.
                # Note: if the instance is a Warm Standby, we end here.
                # FIXME raise an hard error here ?
                ocf_log error "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): instance $OCF_RESOURCE_INSTANCE controldata is not consistent with pg_isready (returned: $pgisready_rc) !"

                return $OCF_ERR_GENERIC
            fi

        elif [ $controldata_rc -eq $OCF_NOT_RUNNING ]; then
            # This state indicates that pg_isready check should fail with rc 2
            # We check again
            _pg_isready
            pgisready_rc=$?
            if [ $pgisready_rc -eq 2 ]; then
                # Consistent with pg_controdata output
                # We check the process status using pg_ctl status and check
                # if it was propertly shut down using pg_controldata
                ocf_log debug "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): instance $OCF_RESOURCE_INSTANCE is not listening."
                _confirm_stopped
                return $?

            else
                # Still not consistent, raise an error.
                # FIXME raise an hard error here ?
                ocf_log error "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): instance $OCF_RESOURCE_INSTANCE controldata is not consistent with pg_isready (returned: $pgisready_rc) !"

                return $OCF_ERR_GENERIC
            fi

        else
            # Something went wrong with the controldata check.
            ocf_log error "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): could not get instance $OCF_RESOURCE_INSTANCE status from controldata (returned: $controldata_rc) !"

            return $controldata_rc
        fi

    elif [ $pgisready_rc -eq 2 ]; then
        # The instance is not listening
        # We check the process status using pg_ctl status and check
        # if it was propertly shut down using pg_controldata
        ocf_log debug "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): instance $OCF_RESOURCE_INSTANCE is not listening."
        _confirm_stopped
        return $?

    elif [ $pgisready_rc -eq 3 ]; then
        # No attempt was done, probably a syntax error
        # Hard configuration error, we don't want to retry or failover here
        ocf_log error "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): unknown error while checking if instance $OCF_RESOURCE_INSTANCE is listening (returned $pgisready_rc) !"

        return $OCF_ERR_CONFIGURED
    fi

    ocf_log error "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): unexpected result when checking instance $OCF_RESOURCE_INSTANCE status."
    return $OCF_ERR_GENERIC
}

# Demote the PostgreSQL from production to standby
# To demote a PostgreSQL instance, we must:
#   * stop it gracefully
#   * create recovery.conf with standby_mode = on
#   * start it
pg_demote() {
    local rc
    local master_score

    pg_monitor
    rc=$?
    case "$rc" in
        "$OCF_RUNNING_MASTER") # Running as master. Normal, expected behavior.
            ocf_log debug "$__OCF_ACTION - pg_demote: currently running as a primary."
            ;;
        "$OCF_SUCCESS") # Alread running as slave. Nothing to do.
            ocf_log debug "$__OCF_ACTION - pg_demote: currently running as a standby."
            return $OCF_SUCCESS
            ;;
        # "$OCF_NOT_RUNNING") # Currently not running. This state is unexpected.
        #     ocf_log error "$__OCF_ACTION - pg_demote: currently not running."
        #     return $OCF_ERR_GENERIC
        #     ;;
        # *) # Failed resource. Let the cluster manager recover.
        #     ocf_log error "$__OCF_ACTION - pg_demote: unexpected error, cannot demote."
        #     return $rc
        #     ;;

        # We actually prefer rising a hard or fatal error instead of leaving
        # the CRM abording its transition for a new one because of a soft error.
        # The hard error will force the CRM to move the resource immediately
        "$OCF_ERR_CONFIGURED")
            return $OCF_ERR_CONFIGURED
            ;;
        *)
            return $OCF_ERR_INSTALLED
            ;;
    esac

    # FIXME we need to make sure at least one slave is connected!!

    # WARNING: the instance **MUST** be stopped gracefully. Do **not** use
    # pg_stop() or service or systemctl here as these commands might force-stop
    # the PostgreSQL instance using immediate after some timeout and return
    # success, which is misleading.
    _runuser "$PGCTL -D ${OCF_RESKEY_pgdata} -m fast -w stop &>/dev/null"
    rc=$?

    # no need to wait for stop to complete, this is handled in pg_ctl using -w
    if [ $? -ne 0 ]; then
        ocf_log error "$__OCF_ACTION - pg_demote: failed to stop $OCF_RESOURCE_INSTANCE using pg_ctl (returned $rc)."
        return $OCF_ERR_GENERIC
    fi

    # Double check that the instance is stopped correctly
    # FIXME: Ask for a higher OCF_CHECK_LEVEL ?
    pg_monitor
    rc=$?
    if [ $rc -ne $OCF_NOT_RUNNING ]; then
        ocf_log error "$__OCF_ACTION - pg_demote: unexpected $OCF_RESOURCE_INSTANCE state: monitor status ($rc) disagree with pg_ctl return code."
        return $OCF_ERR_GENERIC
    fi

    #
    # At this point, the instance **MUST** be stopped gracefully
    #

    # Note: We do not need to handle the recovery.conf file here as pg_start()
    # deal with that itself. Equally, no need to wait for the start to complete
    # here, handled in pg_start().
    pg_start
    rc=$?
    if [ $rc -eq $OCF_SUCCESS ]; then
        ocf_log info "$__OCF_ACTION - pg_demote: $OCF_RESOURCE_INSTANCE started as a standby."
        return $OCF_SUCCESS
    fi

    # NOTE: no need to double check the instance state as pg_start already use
    # pg_monitor to check the state before returning

    ocf_log error "$__OCF_ACTION - pg_demote: starting $OCF_RESOURCE_INSTANCE as a standby failed (returned $rc)."
    return $OCF_ERR_GENERIC
}

# Promote the standby instance to production
#
pg_promote() {
    local rc

    pg_monitor
    rc=$?
    case "$rc" in
        "$OCF_SUCCESS") # Running as slave. Normal, expected behavior.
            ocf_log debug "$__OCF_ACTION - pg_promote: currently running as a standby."
            ;;
        "$OCF_RUNNING_MASTER") # Already a master. Unexpected, but no problem.
            ocf_log info "$__OCF_ACTION - pg_promote: already running as a primary."
            return $OCF_SUCCESS
            ;;
        "$OCF_NOT_RUNNING")
            # FIXME should not happen
            # Currently not running. Need to start before promoting.
            ocf_log info "$__OCF_ACTION - pg_promote: currently not running, starting it."
            pg_start
            rc=$?
            if [ rc -ne $OCF_SUCCESS ]; then
                ocf_log error "$__OCF_ACTION - pg_promote: failed to start the instance."
                return $OCF_ERR_GENERIC
            fi
            ;;
        *) # Failed resource. Let the cluster manager recover.
            ocf_log info "$__OCF_ACTION - pg_promote: unexpected error, cannot promote."
            return $rc
            ;;
    esac

    # 
    # At this point, the instance **MUST** be started as a slave
    #

    # promoting
    _runuser "$PGCTL -D ${OCF_RESKEY_pgdata} -w promote &>/dev/null"
    rc=$?

    # The instance promotion is asynchronous, so we need to wait for this
    # process to complete.
    pg_monitor
    rc=$?
    while [ $rc -ne $OCF_RUNNING_MASTER ] ; do
        ocf_log debug "$__OCF_ACTION - pg_promote: waiting for the promote to complete."
        sleep 1
        pg_monitor
        rc=$?
    done

    ocf_log debug "$__OCF_ACTION - pg_promote: promote completed according to the controldata."

    # Safe tests
    # force a complete check
    OCF_CHECK_LEVEL=10
    pg_monitor
    rc=$?

    if [ $rc -eq $OCF_RUNNING_MASTER -a ! -f "${OCF_RESKEY_pgdata}/recovery.conf" ]; then
        ocf_log info "$__OCF_ACTION - pg_promote: promote complete."
        return $OCF_SUCCESS
    fi

    ocf_log error "$__OCF_ACTION - pg_promote: error while promoting."
    return $OCF_ERR_GENERIC
}

# Called on pre and post actions.
pg_notify() {
    local type_op
    local promoted_node
    local max_delta
    local my_lsn
    local lsn_diff

    type_op="${OCF_RESKEY_CRM_meta_notify_type}-${OCF_RESKEY_CRM_meta_notify_operation}"

    ocf_log debug "$__OCF_ACTION - pg_notify: Received $type_op notification"
    ocf_log debug "$__OCF_ACTION - pg_notify: active_resource: $OCF_RESKEY_CRM_meta_notify_active_resource"
    ocf_log debug "$__OCF_ACTION - pg_notify: inactive_resource: $OCF_RESKEY_CRM_meta_notify_inactive_resource"
    ocf_log debug "$__OCF_ACTION - pg_notify: master_resource: $OCF_RESKEY_CRM_meta_notify_master_resource"
    ocf_log debug "$__OCF_ACTION - pg_notify: slave_resource: $OCF_RESKEY_CRM_meta_notify_slave_resource"
    ocf_log debug "$__OCF_ACTION - pg_notify: start_resource: $OCF_RESKEY_CRM_meta_notify_start_resource"
    ocf_log debug "$__OCF_ACTION - pg_notify: stop_resource: $OCF_RESKEY_CRM_meta_notify_stop_resource"
    ocf_log debug "$__OCF_ACTION - pg_notify: promote_resource: $OCF_RESKEY_CRM_meta_notify_promote_resource"
    ocf_log debug "$__OCF_ACTION - pg_notify: demote_resource: $OCF_RESKEY_CRM_meta_notify_demote_resource"
    ocf_log debug "$__OCF_ACTION - pg_notify: start_uname: $OCF_RESKEY_CRM_meta_notify_start_uname"
    ocf_log debug "$__OCF_ACTION - pg_notify: stop_uname: $OCF_RESKEY_CRM_meta_notify_stop_uname"
    ocf_log debug "$__OCF_ACTION - pg_notify: promote_uname: $OCF_RESKEY_CRM_meta_notify_promote_uname"
    ocf_log debug "$__OCF_ACTION - pg_notify: demote_uname: $OCF_RESKEY_CRM_meta_notify_demote_uname"
    ocf_log debug "$__OCF_ACTION - pg_notify: active_uname: $OCF_RESKEY_CRM_meta_notify_active_uname"
    ocf_log debug "$__OCF_ACTION - pg_notify: inactive_uname: $OCF_RESKEY_CRM_meta_notify_inactive_uname"
    ocf_log debug "$__OCF_ACTION - pg_notify: master_uname: $OCF_RESKEY_CRM_meta_notify_master_uname"
    ocf_log debug "$__OCF_ACTION - pg_notify: slave_uname: $OCF_RESKEY_CRM_meta_notify_slave_uname"

    case $type_op in
        pre-promote)

        # Use communication between instances to have them compare each others
        # xlog location.
        # Only one node : the one designed by 
        #     $OCF_RESKEY_CRM_meta_notify_promote_resource: that way, if it is indeed
        #     the good choice, no need to break the pre-promote
        #     if not, use crm_master to allocate master_score to the highest LSN 
        #     slave, thus hopefuly breaking the pre-promote and triggering another
        #     round

            # the node currently chosen for promotion acts as a reference 
            # point and compare itself the the other nodes
            if $(echo "$OCF_RESKEY_CRM_meta_notify_promote_uname" | grep -q "$NODENAME"); then

                promoted_node="$OCF_RESKEY_CRM_meta_notify_promote_uname"
                max_delta=0

                # get xlog location for the current node
                my_lsn=$(_query "select pg_last_xlog_receive_location()")
                ocf_log debug "$__OCF_ACTION - notify : my xlog location is $my_lsn."

                # parse all nodes eligible for promotion:
                # (slaves + starting - stopping)
                for node in $OCF_RESKEY_CRM_meta_notify_slave_uname $OCF_RESKEY_CRM_meta_notify_start_uname ; do

                    # exclude stopped resources and current node
                    if [ $node != $OCF_RESKEY_CRM_meta_notify_stop_uname -a $node != $(uname -n) ] ; then
                        ocf_log info "$__OCF_ACTION - notify : getting difference with xlog location from node ${node}."

                        # get difference with distant node xlog location
                        lsn_diff=$(_query "select pg_xlog_location_diff(\'${my_lsn}\'::text, pg_last_xlog_receive_location())" "host=$node")

                        ocf_log debug "$__OCF_ACTION - notify : lsn_diff from node ${node} is ${lsn_diff}."

                        # if the distant node xlog location is farther than 
                        # the max found at this point, keep it
                        if [ $lsn_diff -gt $max_delta ]; then
                            promoted_node=$node
                            max_delta=$lsn_diff
                            ocf_log debug "$__OCF_ACTION - notify : found ${node} is a better candidate to promotion."
                        fi

                    fi
                done

                ocf_log info "$__OCF_ACTION - notify : set ${node} as a master."

                # assign master score for current node
                $CRM_MASTER --node $promoted_node --update 1000
            fi
        ;;
    esac
}

pg_reload() {
    # no action necessary, this action is just to inform pacemaker that
    # modification of non-unique parameters can be applied without
    # restarting the resource
    ocf_log info "$__OCF_ACTION - pg_reload : instance $OCF_RESOURCE_INSTANCE reloaded."
    return $OCF_SUCCESS
}

# Validate everything is fine before running the actions
case $current_action in
    start|stop|reload|monitor|promote|demote|notify)
        pgsql_validate_all || exit $? ;;
    # no need to validate for meta-data, methods or validate-all
esac


# Run action
case $current_action in
    start)
        pg_start
        exit $?;;
    stop)
        pg_stop
        exit $?;;
    monitor)
        pg_monitor
        exit $?;;
    promote)
        pg_promote
        exit $?;;
    demote)
        pg_demote
        exit $?;;
    notify)
        pg_notify
        exit $?;;
    reload)
        pg_reload
        exit $?;;
    meta-data)
        ocf_meta_data
        exit 0;;
    methods)
        ocf_methods
        exit 0;;
    validate-all)
        pgsql_validate_all
        exit $?;;
    *)
        exit $OCF_ERR_UNIMPLEMENTED;;
esac
