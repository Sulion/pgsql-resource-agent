#!/bin/bash

#   Resource Agent for managing foobar resources.
#
#   License:      PostgreSQL License (BSD Like)
#   (c) 2012-2013 Jehan-Guillaume de Rorthais, Maël Rimbault

# Initialization
: ${OCF_FUNCTIONS_DIR=${OCF_ROOT}/lib/heartbeat}
. ${OCF_FUNCTIONS_DIR}/ocf-shellfuncs

# Default parameters
OCF_RESKEY_system_user_default="postgres"
OCF_RESKEY_bindir_default="/usr/bin"
OCF_RESKEY_pgdata_default="/var/lib/pgsql/data"
OCF_RESKEY_pgport_default=5432
OCF_RESKEY_recovery_template_default="${OCF_RESKEY_pgdata_default}/recovery.conf.pcmk"

: ${OCF_RESKEY_system_user=${OCF_RESKEY_system_user_default}}
: ${OCF_RESKEY_bindir=${OCF_RESKEY_bindir_default}}
: ${OCF_RESKEY_pgdata=${OCF_RESKEY_pgdata_default}}
: ${OCF_RESKEY_pgport=${OCF_RESKEY_pgport_default}}
: ${OCF_RESKEY_service=${OCF_RESKEY_service_default}}
: ${OCF_RESKEY_recovery_template=${OCF_RESKEY_recovery_template_default}}


function pgsql_validate_all() {
    local rc
    local PGVERSION

    # FIXME
    # http://www.linux-ha.org/doc/dev-guides/_testing_for_binaries_literal_have_binary_literal_and_literal_check_binary_literal.html

    # check binaries
    check_binary "${OCF_RESKEY_bindir}/pg_ctl"
    check_binary "${OCF_RESKEY_bindir}/psql"
    check_binary "${OCF_RESKEY_bindir}/pg_controldata"
    check_binary "${HA_SBIN_DIR}/crm_master"
    check_binary "cp"
    check_binary "sed"
    check_binary "grep"

    # check pgdata
    if [ ! -d "${OCF_RESKEY_pgdata}" ] ; then
        ocf_log error "PGDATA \"${OCF_RESKEY_pgdata}\" doesn't exist";
        return $OCF_ERR_CONFIGURED
    fi

    # check pgdata
    if [ ! -s "${OCF_RESKEY_pgdata}/PG_VERSION" ] ; then
        ocf_log error "PG_VERSION does not exists in \"${OCF_RESKEY_pgdata}\"";
        return $OCF_ERR_CONFIGURED
    fi

    # check system user
    id -nu "${OCF_RESKEY_system_user}" > /dev/null 2>&1
    rc=$?
    if [ ! $rc ] ; then
        ocf_log error "System user \"${OCF_RESKEY_system_user}\" doesn't exist";
        return $OCF_ERR_CONFIGURED
    fi

    # require 9.3 minimum
    PGVERSION="$(cat ${OCF_RESKEY_pgdata}/PG_VERSION)"
    PGVERNUM=$(( ${PGVERSION%.*} * 10000 + ${PGVERSION#*.} * 100 ))
    if [ $PGVERNUM -ge 90300 ] ; then
        ocf_log error "PostgreSQL version $PGVERSION not supported. Require 9.3 and more.";
        return $OCF_ERR_CONFIGURED
    fi

}

ocf_meta_data() {
    cat <<EOF
<?xml version="1.0"?>
<!DOCTYPE resource-agent SYSTEM "ra-api-1.dtd">
<resource-agent name="pgsqlsr">
  <version>1.0</version>

  <longdesc lang="en">
    Resource script for PostgreSQL in replication. It manages PostgreSQL servers using streaming replication as an HA resource.
  </longdesc>
  <shortdesc lang="en">Manages PostgreSQL servers in replication</shortdesc>
  <parameters>
    <parameter name="startable" unique="0" required="0">
      <longdesc lang="en">
        Values for this parameter show which nodes the resource is startable on.
        If not set, all nodes are allowed to run the resource.
        When set to an hostname, it only allows this one node.
        This is automatically done in case of failover, to avoid failback.
      </longdesc>
      <shortdesc lang="en">Nodes allowed to start the resource</shortdesc>
      <content type="string" default="" />
    </parameter>

    <parameter name="system_user" unique="0" required="0">
      <longdesc lang="en">
        System user account used to run the PostgreSQL server
      </longdesc>
      <shortdesc lang="en">PostgreSQL system User</shortdesc>
      <content type="string" default="${OCF_RESKEY_system_user_default}" />
    </parameter>

    <parameter name="bindir" unique="0" required="0">
      <longdesc lang="en">
        Path to the directory storing the PostgreSQL binaries. The agent uses pg_controldata and pg_ctl.
      </longdesc>
      <shortdesc lang="en">Path to the PostgreSQL binaries</shortdesc>
      <content type="string" default="${OCF_RESKEY_bindir_default}" />
    </parameter>

    <parameter name="pgdata" unique="1" required="0">
      <longdesc lang="en">
        Path to the data directory, e.g. PGDATA
      </longdesc>
      <shortdesc lang="en">Path to the data directory</shortdesc>
      <content type="string" default="${OCF_RESKEY_pgdata_default}" />
    </parameter>

    <parameter name="pgport" unique="1" required="0">
      <longdesc lang="en">
        Port the instance is listening on.
      </longdesc>
      <shortdesc lang="en">Instance port</shortdesc>
      <content type="string" default="${OCF_RESKEY_pgport_default}" />
    </parameter>

    <parameter name="recovery_template" unique="1" required="0">
      <longdesc lang="en">
        Path to the recovery.conf template. This file is simply copied to $PGDATA
        before starting the instance as slave
      </longdesc>
      <shortdesc lang="en">Path to the recovery.conf template.</shortdesc>
      <content type="string" default="${OCF_RESKEY_recovery_template_default}" />
    </parameter>

  </parameters>
  <actions>
    <action name="start" timeout="120" />
    <action name="stop" timeout="120" />
    <action name="status" timeout="60" />
    <action name="promote" timeout="60" />
    <action name="demote" timeout="60" />
    <action name="monitor" depth="0" timeout="30" interval="30"/>
    <action name="notify" timeout="60" />
    <action name="meta-data" timeout="5" />
    <action name="validate-all" timeout="5" />
    <action name="methods" timeout="5" />
  </actions>
</resource-agent>
EOF
}

ocf_methods() {
    # FIXME: ajouter methodes
    cat <<EOF
        start
        stop
        status
        promote
        demote
        monitor
        notify
        methods
        meta-data
        validate-all
EOF
}

# Start the PostgreSQL instance as a *slave*
pg_start() {
    local rc
    OCF_CHECK_LEVEL=20

    # instance must be running as slave or being stopped
    # anything else is an error
    pg_monitor
    rc=$?
    if [ $rc -eq $OCF_SUCCESS ]; then
        ocf_log info "$__OCF_ACTION - pg_start: instance $OCF_RESOURCE_INSTANCE already started."
        return $OCF_SUCCESS
    elif [ $rc -ne $OCF_NOT_RUNNING ] ; then
        ocf_log error "$__OCF_ACTION - pg_start: unexpected state for instance $OCF_RESOURCE_INSTANCE (returned $rc)."
        return $OCF_ERR_GENERIC
    fi

    #
    # From here, the instance is NOT running for sure
    #

    # create the recovery.conf file to start as a slave
    cp -f "${OCF_RESKEY_recovery_template}" "${OCF_RESKEY_pgdata}/recovery.conf" &> /dev/null
    rc=$?

    if [ $rc -ne 0 ]; then
        return $OCF_ERR_GENERIC
    fi

    runuser -l "${OCF_RESKEY_system_user}" -c "${OCF_RESKEY_bindir}/pg_ctl -D ${OCF_RESKEY_pgdata} -w start"
    rc=$?

    # wait for the start to finish
    if [ $rc -eq 0 ]; then
        pg_monitor
        rc=$?
        while [ $rc -eq $OCF_NOT_RUNNING ]
        do
            sleep 1
            pg_monitor
            rc=$?
        done

        if [ $rc -eq $OCF_SUCCESS ]; then
            ocf_log info  "$__OCF_ACTION - pg_start: instance $OCF_RESOURCE_INSTANCE started."
        else
            ocf_log error "$__OCF_ACTION - pg_start: instance $OCF_RESOURCE_INSTANCE is not running as a slave (returned $rc)."
        fi

        return $rc
    fi

    ocf_log error "$__OCF_ACTION - pg_start: instance $OCF_RESOURCE_INSTANCE failed to start."
    return $OCF_ERR_GENERIC
}

# Stop the PostgreSQL instance
pg_stop() {
    local rc
    OCF_CHECK_LEVEL=20

    # instance must be running as slave or master or being stopped
    # anything else is an error
    pg_monitor
    rc=$?
    if [ $rc -eq $OCF_NOT_RUNNING ] ; then
        ocf_log info "$__OCF_ACTION - pg_stop: instance $OCF_RESOURCE_INSTANCE already stopped."
        return $OCF_SUCCESS
    elif [ $rc -ne $OCF_SUCCESS -a $rc -ne $OCF_RUNNING_MASTER ]; then
        ocf_log warn "$__OCF_ACTION - pg_stop: unexpected state for instance $OCF_RESOURCE_INSTANCE (returned $rc)."
    fi

    #
    # From here, the instance is running for sure
    #

    # try to quit with proper shutdown
    #FIXME we should add a timeout in pg_ctl call, and try an immediate stop 
    # after that
    runuser -l "${OCF_RESKEY_system_user}" -c "${OCF_RESKEY_bindir}/pg_ctl -D ${OCF_RESKEY_pgdata} -w -m fast stop"
    rc=$?

    # wait for the stop to finish
    if [ $rc -eq 0 ]; then
        pg_monitor
        rc=$?
        while [ $rc -ne $OCF_NOT_RUNNING ]
        do
        #FIXME if proper shutdown does not cut it we need to use immediate stop
        # after some time, and avoid FAILED pacemaker state, which would 
        # trigger fencing
            sleep 1
            pg_monitor
            rc=$?
        done

        ocf_log info  "$__OCF_ACTION - pg_stop: instance $OCF_RESOURCE_INSTANCE stopped."
        return $rc
    fi

    ocf_log error "$__OCF_ACTION - pg_stop: instance $OCF_RESOURCE_INSTANCE failed to stop."
    return $OCF_ERR_GENERIC

}

# Promote the standby instance to production 
pg_promote() {

}

# Monitor the PostgreSQL instance
pg_monitor() {
    local rc
    local pgctl_rc
    local pgisready_rc
    local psql_rc
    local is_in_recovery

    # Light check, pg_ctl
    runuser -l "${OCF_RESKEY_system_user}" -c "${OCF_RESKEY_bindir}/pg_ctl -D ${OCF_RESKEY_pgdata} status"
    pgctl_rc=$?

    # check if PostgreSQL is running or not
    if [ $pgctl_rc -eq 0 ]; then
        ocf_log debug "$__OCF_ACTION - pg_monitor(pg_ctl): instance $OCF_RESOURCE_INSTANCE is running."
    elif [ $pgctl_rc -eq 3 ]; then
        ocf_log debug "$__OCF_ACTION - pg_monitor(pg_ctl): instance $OCF_RESOURCE_INSTANCE is not running."
    else
        # PostgreSQL state is unknown
        ocf_log error "$__OCF_ACTION - pg_monitor(pg_ctl): status of instance $OCF_RESOURCE_INSTANCE is unknown."
        return $OCF_ERR_GENERIC
    fi

    # Medium check, pg_isready
    if [ $OCF_CHECK_LEVEL -ge 10 ]; then
        runuser -l "${OCF_RESKEY_system_user}" -c "${OCF_RESKEY_bindir}/pg_isready -p ${OCF_RESKEY_pgport}"
        pgisready_rc=$?
    
        # check if PostgreSQL is running or not
        if [ $pgisready_rc -eq 0 ]; then
            if [ $pgctl_rc -ne 0 ]; then
                ocf_log warn "$__OCF_ACTION - pg_monitor(pg_isready): inconsistent result between pg_ctl and pg_isready for instance $OCF_RESOURCE_INSTANCE !"
            fi
            ocf_log debug "$__OCF_ACTION - pg_monitor(pg_isready): instance $OCF_RESOURCE_INSTANCE is running."
        elif [ $pgisready_rc -eq 2 ]; then
            ocf_log debug "$__OCF_ACTION - pg_monitor(pg_isready): instance $OCF_RESOURCE_INSTANCE is not running."
        else
            # PostgreSQL state is unknown
            ocf_log error "$__OCF_ACTION - pg_monitor(pg_isready): status of instance $OCF_RESOURCE_INSTANCE is unknown."
            return $OCF_ERR_GENERIC
        fi
    fi

    # Hard check, psql
    if [ $OCF_CHECK_LEVEL -ge 20 ]; then
        runuser -l "${OCF_RESKEY_system_user}" -c "${OCF_RESKEY_bindir}/psql -w -p ${OCF_RESKEY_pgport} -c 'SELECT 1' > /dev/null"
        psql_rc=$?
    
        # check if PostgreSQL is running or not
        if [ $psql_rc -eq 0 ]; then
            if [ $pgctl_rc -ne 0 ]; then
                ocf_log warn "$__OCF_ACTION - pg_monitor(psql): inconsistent result between pg_ctl and psql for instance $OCF_RESOURCE_INSTANCE !"
            fi
            ocf_log debug "$__OCF_ACTION - pg_monitor(psql): instance $OCF_RESOURCE_INSTANCE is running."
        elif [ $psql_rc -eq 2 ]; then
            ocf_log debug "$__OCF_ACTION - pg_monitor(psql): instance $OCF_RESOURCE_INSTANCE is not running."
        else
            # PostgreSQL state is unknown
            ocf_log error "$__OCF_ACTION - pg_monitor(psql): status of instance $OCF_RESOURCE_INSTANCE is unknown."
            return $OCF_ERR_GENERIC
        fi
    fi

    # Return if instance is stopped
    if [ $pgctl_rc -ne 0 -o $pgisready_rc -ne 0 -o $psql_rc -ne 0 ]; then
        ocf_log debug "$__OCF_ACTION - pg_monitor: instance $OCF_RESOURCE_INSTANCE is not running."
        return $OCF_NOT_RUNNING
    fi

    #
    # At this point, instance must be running
    #

    # Check if instance is Primary of Secondary
    is_in_recovery=$(runuser -l "${OCF_RESKEY_system_user}" -c "${OCF_RESKEY_bindir}/psql -AtX -p "${OCF_RESKEY_pgport}" -c 'SELECT pg_is_in_recovery()'")
    if [ $? -ne 0 ]; then
        # FIXME try to check which state the instance was
        ocf_log error "$__OCF_ACTION - pg_monitor: could not check if instance $OCF_RESOURCE_INSTANCE is Primary or Secondary."
        return $OCF_ERR_GENERIC
    fi

    if [ "$is_in_recovery" = "t" ]; then
        ocf_log debug "$__OCF_ACTION - pg_monitor: instance $OCF_RESOURCE_INSTANCE is running as Primary."
        return $OCF_SUCCESS
    elif [ "$is_in_recovery" = "f" ]; then
        ocf_log debug "$__OCF_ACTION - pg_monitor: instance $OCF_RESOURCE_INSTANCE is running as Secondary."
        return $OCF_RUNNING_MASTER
    fi

    ocf_log error "$__OCF_ACTION - pg_monitor: unexpected result when checking instance $OCF_RESOURCE_INSTANCE status."
    return $OCF_ERR_GENERIC
}

# Demote the PostgreSQL from production to standby
pg_demote() {

}

# Called on pre and post actions.
pg_notify() {

}


# Validate everything is fine before running the actions
case $1 in
    start|stop|reload|monitor|promote|demote|notify)
        pgsql_validate_all || exit $? ;;
    # no need to validate for meta-data, methods or validate-all
esac


# Run action
case $1 in
    start)
        pg_start
        exit $?;;
    stop) ;;
    monitor)
        pg_monitor
        exit $?;;
    promote) ;;
    demote) ;;
    notify) ;;
    meta-data)
        ocf_meta_data
        exit 0
        ;;
    methods)
        ocf_methods
        exit 0
        ;;
    validate-all)
        pgsql_validate_all
        exit $?
        ;;
    *)
        exit $OCF_ERR_UNIMPLEMENTED
        ;;
esac
