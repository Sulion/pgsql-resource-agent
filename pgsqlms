#!/bin/bash

#   Resource Agent for managing PostgreSQL resources.
#
#   License:      PostgreSQL License (BSD Like)
#   (c) 2012-2013 Jehan-Guillaume de Rorthais, Maël Rimbault

# Initialization
: ${OCF_FUNCTIONS_DIR=${OCF_ROOT}/lib/heartbeat}
. ${OCF_FUNCTIONS_DIR}/ocf-shellfuncs

# Default parameters
OCF_RESKEY_system_user_default="postgres"
OCF_RESKEY_bindir_default="/usr/bin"
OCF_RESKEY_pgdata_default="/var/lib/pgsql/data"
OCF_RESKEY_pgport_default=5432
OCF_RESKEY_pghost_default="/tmp"

: ${OCF_RESKEY_system_user=${OCF_RESKEY_system_user_default}}
: ${OCF_RESKEY_bindir=${OCF_RESKEY_bindir_default}}
: ${OCF_RESKEY_pgdata=${OCF_RESKEY_pgdata_default}}
: ${OCF_RESKEY_pgport=${OCF_RESKEY_pgport_default}}
: ${OCF_RESKEY_pghost=${OCF_RESKEY_pghost_default}}
: ${OCF_RESKEY_service=${OCF_RESKEY_service_default}}
: ${OCF_RESKEY_recovery_template=${OCF_RESKEY_pgdata}/recovery.conf.pcmk}

# this script expect english output, not random translations depending on
# the system config
export LANG="C"

# PostgreSQL commands path
export PGCTL="${OCF_RESKEY_bindir}/pg_ctl"
export PGPSQL="${OCF_RESKEY_bindir}/psql"
export PGCTRLDATA="${OCF_RESKEY_bindir}/pg_controldata"
export PGISREADY="${OCF_RESKEY_bindir}/pg_isready"
export CRM_MASTER="${HA_SBIN_DIR}/crm_master -l reboot"
export CRM_ATTRIBUTE="${HA_SBIN_DIR}/crm_attribute -l reboot -t status"
export CRM_NODE="${HA_SBIN_DIR}/crm_node"
export CRM_RESOURCE="${HA_SBIN_DIR}/crm_resource"
export NODENAME=$(ocf_local_nodename)

current_action="$1"

function pgsql_validate_all() {
    local rc
    local PGVERSION

    # check binaries
    check_binary "$PGCTL"
    check_binary "$PGPSQL"
    check_binary "$PGCTRLDATA"
    check_binary "$PGISREADY"
    check_binary "${HA_SBIN_DIR}/crm_master"
    check_binary "${HA_SBIN_DIR}/crm_attribute"
    check_binary "$CRM_NODE"
    check_binary "$CRM_RESOURCE"
    check_binary "cp"
    check_binary "sed"
    check_binary "grep"

    # check pgdata
    if [ ! -d "${OCF_RESKEY_pgdata}" ] ; then
        ocf_log error "PGDATA \"${OCF_RESKEY_pgdata}\" doesn't exist";
        return $OCF_ERR_CONFIGURED
    fi

    # check pgdata
    if [ ! -s "${OCF_RESKEY_pgdata}/PG_VERSION" ] ; then
        ocf_log error "PG_VERSION does not exists in \"${OCF_RESKEY_pgdata}\"";
        return $OCF_ERR_CONFIGURED
    fi

    # check recovery template
    if [ ! -f "${OCF_RESKEY_recovery_template}" ] ; then
        ocf_log error "Recovery template '${OCF_RESKEY_recovery_template}' does not exists";
        return $OCF_ERR_CONFIGURED
    fi

    # check system user
    id -nu "${OCF_RESKEY_system_user}" > /dev/null 2>&1
    rc=$?
    if [ ! $rc ] ; then
        ocf_log error "System user \"${OCF_RESKEY_system_user}\" doesn't exist";
        return $OCF_ERR_CONFIGURED
    fi

    # require 9.3 minimum
    PGVERSION="$(cat ${OCF_RESKEY_pgdata}/PG_VERSION)"
    PGVERNUM=$(( ${PGVERSION%.*} * 10000 + ${PGVERSION#*.} * 100 ))
    if [ $PGVERNUM -lt 90300 ] ; then
        ocf_log error "PostgreSQL version $PGVERSION not supported. Require 9.3 and more.";
        return $OCF_ERR_CONFIGURED
    fi

}

ocf_meta_data() {
    cat <<EOF
<?xml version="1.0"?>
<!DOCTYPE resource-agent SYSTEM "ra-api-1.dtd">
<resource-agent name="pgsqlsr">
  <version>1.0</version>

  <longdesc lang="en">
    Resource script for PostgreSQL in replication. It manages PostgreSQL servers using streaming replication as an HA resource.
  </longdesc>
  <shortdesc lang="en">Manages PostgreSQL servers in replication</shortdesc>
  <parameters>
    <parameter name="system_user" unique="0" required="0">
      <longdesc lang="en">
        System user account used to run the PostgreSQL server
      </longdesc>
      <shortdesc lang="en">PostgreSQL system User</shortdesc>
      <content type="string" default="${OCF_RESKEY_system_user_default}" />
    </parameter>

    <parameter name="bindir" unique="0" required="0">
      <longdesc lang="en">
        Path to the directory storing the PostgreSQL binaries. The agent uses pg_controldata and pg_ctl.
      </longdesc>
      <shortdesc lang="en">Path to the PostgreSQL binaries</shortdesc>
      <content type="string" default="${OCF_RESKEY_bindir_default}" />
    </parameter>

    <parameter name="pgdata" unique="1" required="0">
      <longdesc lang="en">
        Path to the data directory, e.g. PGDATA
      </longdesc>
      <shortdesc lang="en">Path to the data directory</shortdesc>
      <content type="string" default="${OCF_RESKEY_pgdata_default}" />
    </parameter>

    <parameter name="pghost" unique="0" required="0">
      <longdesc lang="en">
        Host IP address or unix socket folder the instance is listening on.
      </longdesc>
      <shortdesc lang="en">Instance IP or unix socket folder</shortdesc>
      <content type="string" default="${OCF_RESKEY_pghost_default}" />
    </parameter>

    <parameter name="pgport" unique="0" required="0">
      <longdesc lang="en">
        Port the instance is listening on.
      </longdesc>
      <shortdesc lang="en">Instance port</shortdesc>
      <content type="integer" default="${OCF_RESKEY_pgport_default}" />
    </parameter>

    <parameter name="recovery_template" unique="1" required="0">
      <longdesc lang="en">
        Path to the recovery.conf template. This file is simply copied to $PGDATA
        before starting the instance as slave
      </longdesc>
      <shortdesc lang="en">Path to the recovery.conf template.</shortdesc>
      <content type="string" default="${OCF_RESKEY_pgdata_template}/recovery.conf.pcmk" />
    </parameter>

    <parameter name="primary_node" unique="0" required="0">
      <longdesc lang="en">
        FIXME: DON'T TOUCH THIS
      </longdesc>
      <shortdesc lang="en">FIXME: DON'T TOUCH THIS</shortdesc>
      <content type="string" default="0" />
    </parameter>

    <parameter name="last_primary_lsn" unique="0" required="0">
      <longdesc lang="en">
        FIXME: DON'T TOUCH THIS
      </longdesc>
      <shortdesc lang="en">FIXME: DON'T TOUCH THIS</shortdesc>
      <content type="string" default="0" />
    </parameter>

  </parameters>
  <actions>
    <action name="start" timeout="120" />
    <action name="stop" timeout="120" />
    <action name="status" timeout="60" />
    <action name="reload" timeout="60" />
    <action name="promote" timeout="60" />
    <action name="demote" timeout="120" />
    <action name="monitor" depth="0" timeout="30" interval="30"/>
    <action name="notify" timeout="60" />
    <action name="meta-data" timeout="5" />
    <action name="validate-all" timeout="5" />
    <action name="methods" timeout="5" />
  </actions>
</resource-agent>
EOF
}

ocf_methods() {
    # FIXME: ajouter methodes
    cat <<EOF
        start
        stop
        status
        reload
        promote
        demote
        monitor
        notify
        methods
        meta-data
        validate-all
EOF
}

# Execute command passed as argument with system user
# 
_runuser() {
    local rc

    runuser -l -c "LANG=$LANG $1" "${OCF_RESKEY_system_user}"
    rc=$?

    return $rc
}

# Check if instance is listening on the given host/port
#
_pg_isready() {
    local rc
    local msg

    msg=$($PGISREADY -h "${OCF_RESKEY_pghost}" -p "${OCF_RESKEY_pgport}")
    rc=$?

    ocf_log debug "$__OCF_ACTION - _pg_isready: $msg."

    # possible error codes:
    #   1: ping rejected (usually when instance is in startup, in crash
    #      recovery , in warm standby or a shutdown is in progress)
    #   2: no response, usually means the instance is down
    #   3: no attempt, probably a syntax error, should not happen
    return $rc
}

# Check the postmaster.pid file and the postmaster process.
# WARNING: we do not distinct the scenario where postmaster.pid does not exists
# and the process is still alive. It should be ok though, as this is considered
# as a hard error from monitor.
_pg_ctl_status() {
    local rc

    _runuser "$PGCTL -D ${OCF_RESKEY_pgdata} status &> /dev/null"
    rc=$?

    # possible error codes:
    #   3: postmaster.pid file does not exists OR it does but the process 
    #      with the pid found in the file is not alive
    return $rc
}

_controldata_state() {
    "$PGCTRLDATA" "${OCF_RESKEY_pgdata}" 2>/dev/null | \
        sed -rn 's/^Database cluster state:\s+(.*)/\1/p' 2>/dev/null
}

# Use pg_controldata to check if the state of the PostgreSQL server. This 
# function return codes depending on this state, so we can find wether the 
# instance is Primary or Secondary, or use it to detect any inconsistency
# that could indicate the instance has crashed.
#
_controldata() {
    local CMD
    local inststate

    inststate=$(_controldata_state)

    while [ "$inststate" ]; do
        case $inststate in
            "in production")
                # Instance should be running as a Primary.
                ocf_log debug "$__OCF_ACTION - _controldata: instance $OCF_RESOURCE_INSTANCE state is \"$inststate\"."
                return $OCF_RUNNING_MASTER
                ;;
            "in archive recovery")
                # Instance should be running as a Secondary.
                # This state includes Warm Standby (rejects connections
                # attempts, including pg_isready)
                ocf_log debug "$__OCF_ACTION - _controldata: instance $OCF_RESOURCE_INSTANCE state is \"$inststate\"."
                return $OCF_SUCCESS
                ;;
            "shut down"|"shut down in recovery")
                # The instance should be stopped.
                # We don't care if it was Primary or Secondary before, because
                # we always start instances as Secondaries, and then promotes
                # if necessary.
                ocf_log debug "$__OCF_ACTION - _controldata: instance $OCF_RESOURCE_INSTANCE state is \"$inststate\"."
                return $OCF_NOT_RUNNING
                ;;
            *)
                # The state is "in crash recovery", "starting up" or 
                # "shutting down".
                # This state should be transitional, so we wait and loop to 
                # check if it changes.
                ocf_log debug "$__OCF_ACTION - _controldata: instance $OCF_RESOURCE_INSTANCE state is \"$inststate\": waiting."
                sleep 1
                inststate=$(_controldata_state)
                ;;
        esac
    done

    # If we reach this point, something went wrong with pg_controldata
    # FIXME: better to raise a hard error at this point, like OCF_ERR_CONFIGURED ?
    ocf_log error "$__OCF_ACTION - _controldata: unable get instance $OCF_RESOURCE_INSTANCE state using pg_controldata."
    ocf_log debug "$__OCF_ACTION - _controldata: instance $OCF_RESOURCE_INSTANCE state is \"$instance_state\"."
    return $OCF_ERR_GENERIC

}

# Run a query using psql
#
_query() {
    local rc
    local ANS
    local QUERY="$1"
    local connection_string="port=${OCF_RESKEY_pgport} dbname=postgres $2"


    ANS=$(_runuser "
$PGPSQL -XAt --set='ON_ERROR_STOP=1' '$connection_string' <<EOQ
$QUERY
EOQ
")
    rc=$?

    echo "$ANS"

    # possible error codes:
    #   1: failed to get resources (memory, missing file, ...)
    #   2: unable to connect
    #   3: query failed
    return $rc
}

# Check lsn diff with the current master, and adapt the master score so that 
# the instance with the lower diff will be candidate for promotion
#
_check_lsn_diff() {
    local lsn_primary
    local lsn_diff
    local primary_candidate
    local min_lsndiff
    local node_lsndiff

    # If the primary node attribute has been set, then at least one promotion
    # has occured, so we need to check lsn diff
    if [ -n "${OCF_RESKEY_primary_node}" ] ; then

       lsn_primary=$(_query "select pg_xlog_current_location()" "host=${OCF_RESKEY_primary_node}")

        # Continue this check only if we could get current lsn from the primary
        if [ -n "$lsn_primary" ] ; then
            ocf_log debug "$__OCF_ACTION - _check_lsn_diff: primary node lsn is: ${lsn_primary}."

            # Get lsn diff with primary current lsn
            lsn_diff=$(_query "select pg_xlog_location_diff('${lsn_primary}', pg_last_xlog_receive_location()")
            ocf_log debug "$__OCF_ACTION - _check_lsn_diff: current node lsn diff with primary lsn: ${lsn_diff}."

            # Update lsn_diff node attribute for this node
            $CRM_ATTRIBUTE --node $NODENAME --name lsn_diff --update $lsn_diff
    
            min_lsndiff=$lsn_diff
    
            # Parse the list of available nodes
            for node in $($CRM_NODE --partition) ; do
    
                if [ "$node" != "$NODENAME" -a "$node" != "$OCF_RESKEY_primary_node" ] ; then
                    node_lsndiff=$($CRM_ATTRIBUTE -q --node $node --query --name lsn_diff)
                    ocf_log debug "$__OCF_ACTION - _check_lsn_diff: comparing with ${node}: lsn diff is ${node_lsndiff}."
    
                    # Select the node that had the lower diff, if lower than the 
                    # current node diff
                    if [ -n "$node_lsndiff" -a $node_lsndiff -lt $min_lsndiff ] ; then
                        primary_candidate=$node
                        min_lsndiff=$node_lsndiff
                        ocf_log debug "$__OCF_ACTION - _check_lsn_diff: found ${node} is a better candidate to promotion."
                    fi
    
                fi
    
            done

            # Update last_lsn_primary resource parameter with the value we get
            $CRM_RESOURCE --resource $OCF_RESOURCE_INSTANCE --set-parameter last_primary_lsn --parameter-value "${lsn_primary}"

            # Parse the list of available nodes a second time and adapt the 
            # master scores accordingly
            # FIXME avoid calling crm_master update if scores did not change ?
            for node in $($CRM_NODE --partition) ; do
    
                if [ "$node" == "$primary_candidate" ] ; then
                    ocf_log info "$__OCF_ACTION - _check_lsn_diff: ${primary_candidate} is the better candidate to promotion, updating score accordingly."
                    # Set node master score
                    $CRM_MASTER --node $primary_candidate --update 1000
                elif [ "$node" != "$OCF_RESKEY_primary_node" -a "$node" != "$primary_candidate" ] ; then
                    ocf_log info "$__OCF_ACTION - _check_lsn_diff: node $node is not the better candidate to promotion, updating score accordingly."
                    # Set node master score
                    $CRM_MASTER --node $node --update 1
                fi

            done
                
            return $OCF_SUCCESS
        fi

        ocf_log info "$__OCF_ACTION - _check_lsn_diff: could not get current lsn from primary instance ${OCF_RESKEY_primary_node}."
        return $OCF_ERR_GENERIC
            
    fi

    ocf_log debug "$__OCF_ACTION - _check_lsn_diff: primary_node attribute not set, there was probably no promotion yet."
    return $OCF_SUCCESS

# WARNING will crm_master update trigger a promotion ?

}

# Checks to confirm if the instance is really started if _pg_isready returned
# it should be the case, and to identify whether the instance is Primary or 
# Secondary
#
_confirm_started() {
    local is_in_recovery
    local query_rc
    local controldata_rc

    if [ $OCF_CHECK_LEVEL -ge 10 ]; then
        # Hard check, call psql and pg_is_in_recovery(), and check lsn diff

        is_in_recovery=$(_query "SELECT pg_is_in_recovery()")
        query_rc=$?

        if [ $query_rc -eq 0 ]; then
            # The query was executed, check the result
            if [ "$is_in_recovery" = "t" ]; then
                # The instance is a Secondary.
                ocf_log debug "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): instance $OCF_RESOURCE_INSTANCE is a Secondary."
                # Check lsn diff with current master if any
                _check_lsn_diff
                return $OCF_SUCCESS
            elif [ "$is_in_recovery" = "f" ]; then
                # The instance is a Primary.
                ocf_log debug "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): instance $OCF_RESOURCE_INSTANCE is a Primary."
                return $OCF_RUNNING_MASTER
            fi
            # This should not happen, raise a hard configuration error.
            ocf_log error "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): the query used to check if instance $OCF_RESOURCE_INSTANCE is a Primary or a Secondary sent an unexpected result: \"$is_in_recovery\" !"
            return $OCF_ERR_CONFIGURED
        elif [ $query_rc -eq 1 -o $query_rc -eq 2 ]; then
            # psql cound not connect to the instance
            # FIXME raise an hard error here ?
            ocf_log error "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): psql could not connect to instance $OCF_RESOURCE_INSTANCE !"
            return $OCF_ERR_GENERIC
        elif [ $query_rc -eq 3 ]; then
            # The query failed.
            # This should not happen, raise a hard configuration error.
            ocf_log error "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): the query used to check if instance $OCF_RESOURCE_INSTANCE is a Primary or a Secondary failed !"
            return $OCF_ERR_CONFIGURED
        fi
    fi

    # Soft check, call pg_controldata to check wether Primary or Secondary
    _controldata
    controldata_rc=$?
    if [ $controldata_rc -eq $OCF_NOT_RUNNING ]; then
        # Something went wrong, the instance should not be listening if not
        # running !
        # FIXME raise an hard error here ?
        ocf_log error "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): instance $OCF_RESOURCE_INSTANCE controldata shows that instance is not running, but the instance is listening on local socket !"
        return $OCF_ERR_GENERIC
    elif [ $controldata_rc -eq $OCF_RUNNING_MASTER ]; then
        # The running instance is a Primary
        ocf_log debug "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): instance $OCF_RESOURCE_INSTANCE is a Primary."
        return $OCF_RUNNING_MASTER
    elif [ $controldata_rc -eq $OCF_SUCCESS ]; then
        # The running instance is a Secondary
        ocf_log debug "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): instance $OCF_RESOURCE_INSTANCE is a Secondary."
        return $OCF_SUCCESS
    fi

    # We should not get here, something went wrong
    ocf_log error "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): could not get instance $OCF_RESOURCE_INSTANCE status from controldata (returned: $controldata_rc) !"
    return $controldata_rc

}

# Checks to confirm if the instance is really stopped if _pg_isready returned
# it should be the case, and if it was propertly shut down.
#
_confirm_stopped() {
    local pgctlstatus_rc
    local controldata_rc

    _pg_ctl_status
    pgctlstatus_rc=$?

    if [ $pgctlstatus_rc -eq 0 ]; then
        # The pid file exists and the process is available
        # That should not be the case, return an error
        # FIXME raise an hard error at this point ?
        ocf_log error "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): instance $OCF_RESOURCE_INSTANCE is not listening, but the process referenced in postmaster.pid exists !"
        return $OCF_ERR_GENERIC
    else
        # The pid file does not exists or the process is not available
        ocf_log debug "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): no postmaster process found for instance $OCF_RESOURCE_INSTANCE"

        if [ -f "${OCF_RESKEY_pgdata}/backup_label" ]; then
            # We are probably on a freshly built standby that never start yet.
            ocf_log debug "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): backup_label file exists: probably on a never started standby."
            return $OCF_NOT_RUNNING
        fi

        # Continue the check with pg_controldata
        _controldata
        controldata_rc=$?
        if [ $controldata_rc -eq $OCF_RUNNING_MASTER ]; then
            # The controldata has not been updated to "shutdown"
            # It should mean we had a crash on a Primary instance
            ocf_log error "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): instance $OCF_RESOURCE_INSTANCE controldata indicates a running Primary instance, the instance has probably crashed !"
            return $OCF_FAILED_MASTER
        elif [ $controldata_rc -eq $OCF_SUCCESS ]; then
            # The controldata has not been updated to "shutdown in recovery"
            # It should mean we had a crash on a Secondary instance
            # There is no "FAILED_SLAVE" return code, so we return a 
            # generic error
            ocf_log error "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): instance $OCF_RESOURCE_INSTANCE controldata indicates a running Secondary instance, the instance has probably crashed !"
            return $OCF_ERR_GENERIC
        elif [ $controldata_rc -eq $OCF_NOT_RUNNING ]; then
            # The controldata state is consistent, the instance was
            # probably propertly shut down.
            ocf_log debug "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): instance $OCF_RESOURCE_INSTANCE controldata indicates that the instance was propertly shut down."
            return $OCF_NOT_RUNNING
        else
            # Something went wrong with the controldata check.
            ocf_log error "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): could not get instance $OCF_RESOURCE_INSTANCE status from controldata (returned: $controldata_rc) !"
            return $controldata_rc
        fi
    fi

}

# Start the PostgreSQL instance as a *slave*
pg_start() {
    local rc
    OCF_CHECK_LEVEL=20

    # instance must be running as slave or being stopped
    # anything else is an error
    pg_monitor
    rc=$?
    if [ $rc -eq $OCF_SUCCESS ]; then
        ocf_log info "$__OCF_ACTION - pg_start: instance $OCF_RESOURCE_INSTANCE already started."
        return $OCF_SUCCESS
    elif [ $rc -ne $OCF_NOT_RUNNING ] ; then
        ocf_log error "$__OCF_ACTION - pg_start: unexpected state for instance $OCF_RESOURCE_INSTANCE (returned $rc)."
        return $OCF_ERR_GENERIC
    fi

    #
    # From here, the instance is NOT running for sure
    #

    # create the recovery.conf file to start as a standby
    # NOTE: the recovery.conf is supposed to be set up so the standby can
    # connect to the instance in production. As there is no instance in
    # production on start, standbys will bail about failing to connect to
    # the primary.
    # As we can not reload a recovery.conf file on a standby without restarting
    # it, we will leave with this.
    cp -f "${OCF_RESKEY_recovery_template}" "${OCF_RESKEY_pgdata}/recovery.conf"
    rc=$?
    chown "${OCF_RESKEY_system_user}": "${OCF_RESKEY_pgdata}/recovery.conf"
    rc=$((rc + $?))
    chmod 0644 "${OCF_RESKEY_pgdata}/recovery.conf"
    rc=$((rc + $?))

    if [ $rc -ne 0 ]; then
        return $OCF_ERR_GENERIC
    fi

    _runuser "$PGCTL -D ${OCF_RESKEY_pgdata} -w start &>/dev/null"
    rc=$?

    # wait for the start to finish
    if [ $rc -eq 0 ]; then
        pg_monitor
        rc=$?
        while [ $rc -eq $OCF_NOT_RUNNING ]
        do
            sleep 1
            pg_monitor
            rc=$?
        done

        if [ $rc -eq $OCF_SUCCESS ]; then
            ocf_log info  "$__OCF_ACTION - pg_start: instance $OCF_RESOURCE_INSTANCE started."

            if [ "$current_action" == "start" ]; then
                # set master score to 1 so the node can be promoted
                ocf_log debug "$__OCF_ACTION - pg_start: instance started as a secondary, set master score to 1."
                $CRM_MASTER --update 1
            fi
        else
            ocf_log error "$__OCF_ACTION - pg_start: instance $OCF_RESOURCE_INSTANCE is not running as a slave (returned $rc)."
        fi

        return $rc
    fi

    ocf_log error "$__OCF_ACTION - pg_start: instance $OCF_RESOURCE_INSTANCE failed to start."
    return $OCF_ERR_GENERIC

}

# Stop the PostgreSQL instance
pg_stop() {
    local rc
    local state
    local PIDFILE="${OCF_RESKEY_pgdata}/postmaster.pid"
    OCF_CHECK_LEVEL=20

    # instance must be running as slave or master or being stopped
    # anything else is an error
    pg_monitor
    rc=$?
    if [ $rc -eq $OCF_NOT_RUNNING ] ; then
        ocf_log info "$__OCF_ACTION - pg_stop: instance $OCF_RESOURCE_INSTANCE already stopped."
        return $OCF_SUCCESS
    elif [ $rc -ne $OCF_SUCCESS -a $rc -ne $OCF_RUNNING_MASTER ]; then
        ocf_log warn "$__OCF_ACTION - pg_stop: unexpected state for instance $OCF_RESOURCE_INSTANCE (returned $rc)."
    fi

    #
    # From here, the instance is running for sure
    #

    _controldata
    state=$?

    # try to quit with proper shutdown
    #FIXME we should add a timeout in pg_ctl call, and try an immediate stop 
    # after that
    _runuser "$PGCTL -D ${OCF_RESKEY_pgdata} -w -m fast stop &>/dev/null"
    rc=$?

    if [ $rc -eq 1 -a ! -f "$PIDFILE" -a state -eq $OCF_NOT_RUNNING ]; then
        return $OCF_SUCCESS
    fi

    # wait for the stop to finish
    if [ $rc -eq 0 ]; then
        pg_monitor
        rc=$?
        while [ $rc -ne $OCF_NOT_RUNNING ]
        do
        #FIXME if proper shutdown does not cut it we need to use immediate stop
        # after some time, and avoid FAILED pacemaker state, which would 
        # trigger fencing
            sleep 1
            pg_monitor
            rc=$?
        done

        ocf_log info  "$__OCF_ACTION - pg_stop: instance $OCF_RESOURCE_INSTANCE stopped."
        return $OCF_SUCCESS
    fi

    ocf_log error "$__OCF_ACTION - pg_stop: instance $OCF_RESOURCE_INSTANCE failed to stop."
    return $OCF_ERR_GENERIC

}

# Monitor the PostgreSQL instance
pg_monitor() {
    local pgisready_rc
    local controldata_rc

    if ocf_is_probe; then
        ocf_log debug "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): monitor is a probe."
    fi

    # First check, verify if the instance is listening
    _pg_isready
    pgisready_rc=$?

    if [ $pgisready_rc -eq 0 ]; then
        # The instance is listening
        # We confirm that the instance is up and get if it is a Primary or a
        # Secondary using pg_controldata (OCF_CHECK_LEVEL < 10) or psql and 
        # pg_is_in_recovery() (OCF_CHECK_LEVEL >= 10).
        ocf_log debug "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): instance $OCF_RESOURCE_INSTANCE is listening."
        _confirm_started
        return $?

    elif [ $pgisready_rc -eq 1 ]; then
        # The attempt was rejected.
        # This could happen in several cases:
        #   - at startup
        #   - during shutdown
        #   - during crash recovery
        #   - if instance is a warm standby
        # Except for the Warm standby case, this should be a transitional state
        # We try to confirm using pg_controldata
        ocf_log debug "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): instance $OCF_RESOURCE_INSTANCE rejects connections - we check again."
        _controldata
        controldata_rc=$?
        if [ $controldata_rc -eq $OCF_RUNNING_MASTER -o $controldata_rc -eq $OCF_SUCCESS]; then
            # This state indicates that pg_isready check should succeed
            # We check again
            ocf_log debug "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): instance $OCF_RESOURCE_INSTANCE controldata shows a running status."
            _pg_isready
            pgisready_rc=$?
            if [ $pgisready_rc -eq 0 ]; then
                # Consistent with pg_controdata output
                # We can check if the instance is Primary or Secondary using 
                # pg_controldata (OCF_CHECK_LEVEL < 10) or psql and 
                # pg_is_in_recovery() (OCF_CHECK_LEVEL >= 10).
                ocf_log debug "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): instance $OCF_RESOURCE_INSTANCE is listening."
                _confirm_started
                return $?

            else
                # Still not consistent, raise an error.
                # Note: if the instance is a Warm Standby, we end here.
                # FIXME raise an hard error here ?
                ocf_log error "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): instance $OCF_RESOURCE_INSTANCE controldata is not consistent with pg_isready (returned: $pgisready_rc) !"

                return $OCF_ERR_GENERIC
            fi

        elif [ $controldata_rc -eq $OCF_NOT_RUNNING ]; then
            # This state indicates that pg_isready check should fail with rc 2
            # We check again
            _pg_isready
            pgisready_rc=$?
            if [ $pgisready_rc -eq 2 ]; then
                # Consistent with pg_controdata output
                # We check the process status using pg_ctl status and check
                # if it was propertly shut down using pg_controldata
                ocf_log debug "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): instance $OCF_RESOURCE_INSTANCE is not listening."
                _confirm_stopped
                return $?

            else
                # Still not consistent, raise an error.
                # FIXME raise an hard error here ?
                ocf_log error "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): instance $OCF_RESOURCE_INSTANCE controldata is not consistent with pg_isready (returned: $pgisready_rc) !"

                return $OCF_ERR_GENERIC
            fi

        else
            # Something went wrong with the controldata check.
            ocf_log error "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): could not get instance $OCF_RESOURCE_INSTANCE status from controldata (returned: $controldata_rc) !"

            return $controldata_rc
        fi

    elif [ $pgisready_rc -eq 2 ]; then
        # The instance is not listening
        # We check the process status using pg_ctl status and check
        # if it was propertly shut down using pg_controldata
        ocf_log debug "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): instance $OCF_RESOURCE_INSTANCE is not listening."
        _confirm_stopped
        return $?

    elif [ $pgisready_rc -eq 3 ]; then
        # No attempt was done, probably a syntax error
        # Hard configuration error, we don't want to retry or failover here
        ocf_log error "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): unknown error while checking if instance $OCF_RESOURCE_INSTANCE is listening (returned $pgisready_rc) !"

        return $OCF_ERR_CONFIGURED
    fi

    ocf_log error "$__OCF_ACTION - pg_monitor($OCF_CHECK_LEVEL): unexpected result when checking instance $OCF_RESOURCE_INSTANCE status."
    return $OCF_ERR_GENERIC
}

# Demote the PostgreSQL from production to standby
# To demote a PostgreSQL instance, we must:
#   * stop it gracefully
#   * create recovery.conf with standby_mode = on
#   * start it
pg_demote() {
    local rc
    local master_score

    pg_monitor
    rc=$?
    case "$rc" in
        "$OCF_RUNNING_MASTER") # Running as master. Normal, expected behavior.
            ocf_log debug "$__OCF_ACTION - pg_demote: currently running as a primary."
            ;;
        "$OCF_SUCCESS") # Alread running as slave. Nothing to do.
            ocf_log debug "$__OCF_ACTION - pg_demote: currently running as a standby."
            return $OCF_SUCCESS
            ;;
        # "$OCF_NOT_RUNNING") # Currently not running. This state is unexpected.
        #     ocf_log error "$__OCF_ACTION - pg_demote: currently not running."
        #     return $OCF_ERR_GENERIC
        #     ;;
        # *) # Failed resource. Let the cluster manager recover.
        #     ocf_log error "$__OCF_ACTION - pg_demote: unexpected error, cannot demote."
        #     return $rc
        #     ;;

        # We actually prefer rising a hard or fatal error instead of leaving
        # the CRM abording its transition for a new one because of a soft error.
        # The hard error will force the CRM to move the resource immediately
        "$OCF_ERR_CONFIGURED")
            return $OCF_ERR_CONFIGURED
            ;;
        *)
            return $OCF_ERR_INSTALLED
            ;;
    esac

    # FIXME we need to make sure at least one slave is connected!!

    # WARNING: the instance **MUST** be stopped gracefully. Do **not** use
    # pg_stop() or service or systemctl here as these commands might force-stop
    # the PostgreSQL instance using immediate after some timeout and return
    # success, which is misleading.
    _runuser "$PGCTL -D ${OCF_RESKEY_pgdata} -m fast -w stop &>/dev/null"
    rc=$?

    # no need to wait for stop to complete, this is handled in pg_ctl using -w
    if [ $? -ne 0 ]; then
        ocf_log error "$__OCF_ACTION - pg_demote: failed to stop $OCF_RESOURCE_INSTANCE using pg_ctl (returned $rc)."
        return $OCF_ERR_GENERIC
    fi

    # Double check that the instance is stopped correctly
    # FIXME: Ask for a higher OCF_CHECK_LEVEL ?
    pg_monitor
    rc=$?
    if [ $rc -ne $OCF_NOT_RUNNING ]; then
        ocf_log error "$__OCF_ACTION - pg_demote: unexpected $OCF_RESOURCE_INSTANCE state: monitor status ($rc) disagree with pg_ctl return code."
        return $OCF_ERR_GENERIC
    fi

    #
    # At this point, the instance **MUST** be stopped gracefully
    #

    # Note: We do not need to handle the recovery.conf file here as pg_start()
    # deal with that itself. Equally, no need to wait for the start to complete
    # here, handled in pg_start().
    pg_start
    rc=$?
    if [ $rc -eq $OCF_SUCCESS ]; then
        ocf_log info "$__OCF_ACTION - pg_demote: $OCF_RESOURCE_INSTANCE started as a standby."
        return $OCF_SUCCESS
    fi

    # NOTE: no need to double check the instance state as pg_start already use
    # pg_monitor to check the state before returning

    ocf_log error "$__OCF_ACTION - pg_demote: starting $OCF_RESOURCE_INSTANCE as a standby failed (returned $rc)."
    return $OCF_ERR_GENERIC
}

# Promote the standby instance to production
#
pg_promote() {
    local rc

    pg_monitor
    rc=$?
    case "$rc" in
        "$OCF_SUCCESS") # Running as slave. Normal, expected behavior.
            ocf_log debug "$__OCF_ACTION - pg_promote: currently running as a standby."
            ;;
        "$OCF_RUNNING_MASTER") # Already a master. Unexpected, but no problem.
            ocf_log info "$__OCF_ACTION - pg_promote: already running as a primary."
            return $OCF_SUCCESS
            ;;
        "$OCF_NOT_RUNNING")
            # FIXME should not happen
            # Currently not running. Need to start before promoting.
            ocf_log info "$__OCF_ACTION - pg_promote: currently not running, starting it."
            pg_start
            rc=$?
            if [ rc -ne $OCF_SUCCESS ]; then
                ocf_log error "$__OCF_ACTION - pg_promote: failed to start the instance."
                return $OCF_ERR_GENERIC
            fi
            ;;
        *) # Failed resource. Let the cluster manager recover.
            ocf_log info "$__OCF_ACTION - pg_promote: unexpected error, cannot promote."
            return $rc
            ;;
    esac

    # 
    # At this point, the instance **MUST** be started as a slave
    #

    # If primary_node resource attribute has been set, this is not the first 
    # promotion, thus it is necessary to compare lsn between nodes
    if [ -n "$OCF_RESKEY_primary_node" ] ; then
        local node_to_promote
        local min_lsndiff
        local node_lsndiff
    
        min_lsndiff=$($CRM_ATTRIBUTE --node $NODENAME -q --query --name lsn_diff)
    
        # Parse the list of available nodes
        # FIXME instead of crm_node, use a resource attribute set during 
        #   notify using $OCF_RESKEY_CRM_meta_notify_slave_uname and 
        #   $OCF_RESKEY_CRM_meta_notify_start_uname ?
        for node in $($CRM_NODE --partition) ; do
    
            if [ "$node" != "$NODENAME" ] ; then
                node_lsndiff=$($CRM_ATTRIBUTE -q --node $node --query --name lsn_diff)
                ocf_log debug "$__OCF_ACTION - pg_promote: comparing with ${node}: lsn diff is ${node_lsndiff}."
    
                # Select the node that had the lower diff, if lower than the 
                # current node diff
                if [ -n "$node_lsndiff" -a $node_lsndiff -lt $min_lsndiff ] ; then
                    node_to_promote=$node
                    min_lsndiff=$node_lsndiff
                    ocf_log debug "$__OCF_ACTION - pg_promote: found ${node} is a better candidate to promotion."
                fi

            fi

        done
    
        # If any node has been selected, we adapt the master scores accordingly
        # and break the current promotion
        if [ -n "$node_to_promote" ] ; then
            ocf_log info "$__OCF_ACTION - pg_promote: ${node_to_promote} is the better candidate to promotion, aborting current promotion."
            # reset current node master score
            $CRM_MASTER --update 1
            # set promotion candidate master score
            $CRM_MASTER --node $node_to_promote --update 1000
            # We fail the promotion to trigger another promotion transition 
            # with the new scores
            # FIXME is there any other way at this point to trigger this 
            # without failing the promote action ?
            return $OCF_ERR_GENERIC
        fi

        # Else, we will keep on promoting the current node

    fi

    _runuser "$PGCTL -D ${OCF_RESKEY_pgdata} -w promote &>/dev/null"
    rc=$?

    # The instance promotion is asynchronous, so we need to wait for this
    # process to complete.
    pg_monitor
    rc=$?
    while [ $rc -ne $OCF_RUNNING_MASTER ] ; do
        ocf_log debug "$__OCF_ACTION - pg_promote: waiting for the promote to complete."
        sleep 1
        pg_monitor
        rc=$?
    done

    ocf_log debug "$__OCF_ACTION - pg_promote: promote completed according to the controldata."

    # Safe tests
    # force a complete check
    OCF_CHECK_LEVEL=10
    pg_monitor
    rc=$?

    if [ $rc -eq $OCF_RUNNING_MASTER -a ! -f "${OCF_RESKEY_pgdata}/recovery.conf" ]; then
        ocf_log info "$__OCF_ACTION - pg_promote: promote complete."
        # Set master score to 1001 for this node so it sticks to this role
        $CRM_MASTER --update 1001
        return $OCF_SUCCESS
    fi

    ocf_log error "$__OCF_ACTION - pg_promote: error while promoting."
    return $OCF_ERR_GENERIC
}

# Called on pre and post actions.
pg_notify() {
    local type_op
    local promoted_node
    local max_delta
    local my_lsn
    local lsn_diff

    type_op="${OCF_RESKEY_CRM_meta_notify_type}-${OCF_RESKEY_CRM_meta_notify_operation}"

    ocf_log debug "$__OCF_ACTION - pg_notify: Received $type_op notification"
    ocf_log debug "$__OCF_ACTION - pg_notify: active_resource: $OCF_RESKEY_CRM_meta_notify_active_resource"
    ocf_log debug "$__OCF_ACTION - pg_notify: inactive_resource: $OCF_RESKEY_CRM_meta_notify_inactive_resource"
    ocf_log debug "$__OCF_ACTION - pg_notify: master_resource: $OCF_RESKEY_CRM_meta_notify_master_resource"
    ocf_log debug "$__OCF_ACTION - pg_notify: slave_resource: $OCF_RESKEY_CRM_meta_notify_slave_resource"
    ocf_log debug "$__OCF_ACTION - pg_notify: start_resource: $OCF_RESKEY_CRM_meta_notify_start_resource"
    ocf_log debug "$__OCF_ACTION - pg_notify: stop_resource: $OCF_RESKEY_CRM_meta_notify_stop_resource"
    ocf_log debug "$__OCF_ACTION - pg_notify: promote_resource: $OCF_RESKEY_CRM_meta_notify_promote_resource"
    ocf_log debug "$__OCF_ACTION - pg_notify: demote_resource: $OCF_RESKEY_CRM_meta_notify_demote_resource"
    ocf_log debug "$__OCF_ACTION - pg_notify: start_uname: $OCF_RESKEY_CRM_meta_notify_start_uname"
    ocf_log debug "$__OCF_ACTION - pg_notify: stop_uname: $OCF_RESKEY_CRM_meta_notify_stop_uname"
    ocf_log debug "$__OCF_ACTION - pg_notify: promote_uname: $OCF_RESKEY_CRM_meta_notify_promote_uname"
    ocf_log debug "$__OCF_ACTION - pg_notify: demote_uname: $OCF_RESKEY_CRM_meta_notify_demote_uname"
    ocf_log debug "$__OCF_ACTION - pg_notify: active_uname: $OCF_RESKEY_CRM_meta_notify_active_uname"
    ocf_log debug "$__OCF_ACTION - pg_notify: inactive_uname: $OCF_RESKEY_CRM_meta_notify_inactive_uname"
    ocf_log debug "$__OCF_ACTION - pg_notify: master_uname: $OCF_RESKEY_CRM_meta_notify_master_uname"
    ocf_log debug "$__OCF_ACTION - pg_notify: slave_uname: $OCF_RESKEY_CRM_meta_notify_slave_uname"

    case $type_op in
        pre-promote)

            local lsn_diff

            ocf_log info "$__OCF_ACTION - notify : promoting instance on node ${OCF_RESKEY_CRM_meta_notify_promote_uname}."

            # Compute lsn difference with last known primary position, 
            # pg_promote will then check if instance to be promoted within the
            # current transition is the good one
            # If this is the first promotion, last_primary_lsn will not be set
            # in that case, there is no point to try computing this diff
            if [ -n "$OCF_RESKEY_last_primary_lsn" ] ; then
                lsn_diff=$(_query "select pg_xlog_location_diff('${OCF_RESKEY_last_primary_lsn}', pg_last_xlog_receive_location())")
                ocf_log debug "$__OCF_ACTION - notify : current node lsn diff with primary last known lsn: ${lsn_diff}."
                $CRM_ATTRIBUTE --node $NODENAME --name lsn_diff --update $lsn_diff
            fi

        ;;
        post-promote)
            # FIXME do we need to do something else at this point ?
            ocf_log info "$__OCF_ACTION - notify : instance on node ${OCF_RESKEY_CRM_meta_notify_promote_uname} has been promoted."
        ;;
    esac
}

pg_reload() {
    # no action necessary, this action is just to inform pacemaker that
    # modification of non-unique parameters can be applied without
    # restarting the resource
    ocf_log info "$__OCF_ACTION - pg_reload : instance $OCF_RESOURCE_INSTANCE reloaded."
    return $OCF_SUCCESS
}

# Validate everything is fine before running the actions
case $current_action in
    start|stop|reload|monitor|promote|demote|notify)
        pgsql_validate_all || exit $? ;;
    # no need to validate for meta-data, methods or validate-all
esac


# Run action
case $current_action in
    start)
        pg_start
        exit $?;;
    stop)
        pg_stop
        exit $?;;
    monitor)
        pg_monitor
        exit $?;;
    promote)
        pg_promote
        exit $?;;
    demote)
        pg_demote
        exit $?;;
    notify)
        pg_notify
        exit $?;;
    reload)
        pg_reload
        exit $?;;
    meta-data)
        ocf_meta_data
        exit 0;;
    methods)
        ocf_methods
        exit 0;;
    validate-all)
        pgsql_validate_all
        exit $?;;
    *)
        exit $OCF_ERR_UNIMPLEMENTED;;
esac
