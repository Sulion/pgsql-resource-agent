#!/bin/bash

#   Resource Agent for managing foobar resources.
#
#   License:      PostgreSQL License (BSD Like)
#   (c) 2012-2013 Jehan-Guillaume de Rorthais, Maël Rimbault

# Initialization
: ${OCF_FUNCTIONS_DIR=${OCF_ROOT}/lib/heartbeat}
. ${OCF_FUNCTIONS_DIR}/ocf-shellfuncs

# Default parameters
OCF_RESKEY_system_user_default="postgres"
OCF_RESKEY_bindir_default="/usr/bin"
OCF_RESKEY_pgdata_default="/var/lib/pgsql/data"
OCF_RESKEY_pgport_default=5432
OCF_RESKEY_pghost_default="/tmp"
OCF_RESKEY_recovery_template_default="${OCF_RESKEY_pgdata_default}/recovery.conf.pcmk"

: ${OCF_RESKEY_system_user=${OCF_RESKEY_system_user_default}}
: ${OCF_RESKEY_bindir=${OCF_RESKEY_bindir_default}}
: ${OCF_RESKEY_pgdata=${OCF_RESKEY_pgdata_default}}
: ${OCF_RESKEY_pgport=${OCF_RESKEY_pgport_default}}
: ${OCF_RESKEY_pghost=${OCF_RESKEY_pghost_default}}
: ${OCF_RESKEY_service=${OCF_RESKEY_service_default}}
: ${OCF_RESKEY_recovery_template=${OCF_RESKEY_recovery_template_default}}

# this script expect english output, not random translations depending on
# the system config
export LANG="C"

function pgsql_validate_all() {
    local rc
    local PGVERSION

    # FIXME
    # http://www.linux-ha.org/doc/dev-guides/_testing_for_binaries_literal_have_binary_literal_and_literal_check_binary_literal.html

    # check binaries
    check_binary "${OCF_RESKEY_bindir}/pg_ctl"
    check_binary "${OCF_RESKEY_bindir}/psql"
    check_binary "${OCF_RESKEY_bindir}/pg_controldata"
    check_binary "${HA_SBIN_DIR}/crm_master"
    check_binary "cp"
    check_binary "sed"
    check_binary "grep"

    # check pgdata
    if [ ! -d "${OCF_RESKEY_pgdata}" ] ; then
        ocf_log error "PGDATA \"${OCF_RESKEY_pgdata}\" doesn't exist";
        return $OCF_ERR_CONFIGURED
    fi

    # check pgdata
    if [ ! -s "${OCF_RESKEY_pgdata}/PG_VERSION" ] ; then
        ocf_log error "PG_VERSION does not exists in \"${OCF_RESKEY_pgdata}\"";
        return $OCF_ERR_CONFIGURED
    fi

    # check system user
    id -nu "${OCF_RESKEY_system_user}" > /dev/null 2>&1
    rc=$?
    if [ ! $rc ] ; then
        ocf_log error "System user \"${OCF_RESKEY_system_user}\" doesn't exist";
        return $OCF_ERR_CONFIGURED
    fi

    # require 9.3 minimum
    PGVERSION="$(cat ${OCF_RESKEY_pgdata}/PG_VERSION)"
    PGVERNUM=$(( ${PGVERSION%.*} * 10000 + ${PGVERSION#*.} * 100 ))
    if [ $PGVERNUM -ge 90300 ] ; then
        ocf_log error "PostgreSQL version $PGVERSION not supported. Require 9.3 and more.";
        return $OCF_ERR_CONFIGURED
    fi

}

ocf_meta_data() {
    cat <<EOF
<?xml version="1.0"?>
<!DOCTYPE resource-agent SYSTEM "ra-api-1.dtd">
<resource-agent name="pgsqlsr">
  <version>1.0</version>

  <longdesc lang="en">
    Resource script for PostgreSQL in replication. It manages PostgreSQL servers using streaming replication as an HA resource.
  </longdesc>
  <shortdesc lang="en">Manages PostgreSQL servers in replication</shortdesc>
  <parameters>
    <parameter name="system_user" unique="0" required="0">
      <longdesc lang="en">
        System user account used to run the PostgreSQL server
      </longdesc>
      <shortdesc lang="en">PostgreSQL system User</shortdesc>
      <content type="string" default="${OCF_RESKEY_system_user_default}" />
    </parameter>

    <parameter name="bindir" unique="0" required="0">
      <longdesc lang="en">
        Path to the directory storing the PostgreSQL binaries. The agent uses pg_controldata and pg_ctl.
      </longdesc>
      <shortdesc lang="en">Path to the PostgreSQL binaries</shortdesc>
      <content type="string" default="${OCF_RESKEY_bindir_default}" />
    </parameter>

    <parameter name="pgdata" unique="1" required="0">
      <longdesc lang="en">
        Path to the data directory, e.g. PGDATA
      </longdesc>
      <shortdesc lang="en">Path to the data directory</shortdesc>
      <content type="string" default="${OCF_RESKEY_pgdata_default}" />
    </parameter>

    <parameter name="pghost" unique="0" required="0">
      <longdesc lang="en">
        Host IP address or unix socket folder the instance is listening on.
      </longdesc>
      <shortdesc lang="en">Instance IP or unix socket folder</shortdesc>
      <content type="string" default="${OCF_RESKEY_pghost_default}" />
    </parameter>

    <parameter name="pgport" unique="0" required="0">
      <longdesc lang="en">
        Port the instance is listening on.
      </longdesc>
      <shortdesc lang="en">Instance port</shortdesc>
      <content type="integer" default="${OCF_RESKEY_pgport_default}" />
    </parameter>

    <parameter name="recovery_template" unique="1" required="0">
      <longdesc lang="en">
        Path to the recovery.conf template. This file is simply copied to $PGDATA
        before starting the instance as slave
      </longdesc>
      <shortdesc lang="en">Path to the recovery.conf template.</shortdesc>
      <content type="string" default="${OCF_RESKEY_recovery_template_default}" />
    </parameter>

  </parameters>
  <actions>
    <action name="start" timeout="120" />
    <action name="stop" timeout="120" />
    <action name="status" timeout="60" />
    <action name="promote" timeout="60" />
    <action name="demote" timeout="120" />
    <action name="monitor" depth="0" timeout="30" interval="30"/>
    <action name="notify" timeout="60" />
    <action name="meta-data" timeout="5" />
    <action name="validate-all" timeout="5" />
    <action name="methods" timeout="5" />
  </actions>
</resource-agent>
EOF
}

ocf_methods() {
    # FIXME: ajouter methodes
    cat <<EOF
        start
        stop
        status
        promote
        demote
        monitor
        notify
        methods
        meta-data
        validate-all
EOF
}

# Check if instance is listening on the given host/port
#
_pg_isready() {
    local rc

    "${OCF_RESKEY_bindir}"/pg_isready -h "${OCF_RESKEY_pghost}" -p "${OCF_RESKEY_pgport}"
    rc=$?

    # possible error codes:
    #   1: ping rejected (usually when instance is in startup, in crash
    #      recovery , in warm standby or a shutdown is in progress)
    #   2: no response, usually means the instance is down
    #   3: no attempt, probably a syntax error, should not happen
    return $rc
    
}

# Check the postmaster.pid file and the postmaster process.
# WARNING: we do not distinct the scenario where postmaster.pid does not exists
# and the process is still alive. It should be ok though, as this is considered
# as a hard error from monitor.
_pg_ctl_status() {
    local rc

    runuser -l "${OCF_RESKEY_system_user}" -c "${OCF_RESKEY_bindir}/pg_ctl -D ${OCF_RESKEY_pgdata} status &> /dev/null"
    rc=$?

    # possible error codes:
    #   3: postmaster.pid file does not exists OR it does but the process 
    #      with the pid found in the file is not alive
    return $rc

}

# Use pg_controldata to check if the state of the PostgreSQL server. This 
# function return codes depending on this state, so we can find wether the 
# instance is Primary or Secondary, or use it to detect any inconsistency
# that could indicate the instance has crashed.
#
_controldata() {
    local CMD
    local inststate

    CMD="${OCF_RESKEY_bindir}/pg_controldata ${OCF_RESKEY_pgdata} 2>/dev/null | \
        sed -rn 's/^Database cluster state:\s+(.*)/\1/p' 2>/dev/null"
    inststate=$($CMD)

    while [ "$inststate" ]; do
        case $inststate in
            "in production")
                # Instance should be running as a Primary.
                ocf_log debug "$__OCF_ACTION - _controldata: instance $OCF_RESOURCE_INSTANCE state is \"$inststate\"."
                return $OCF_RUNNING_MASTER
                ;;
            "in archive recovery")
                # Instance should be running as a Secondary.
                # This state includes Warm Standby (rejects connections
                # attempts, including pg_isready)
                ocf_log debug "$__OCF_ACTION - _controldata: instance $OCF_RESOURCE_INSTANCE state is \"$inststate\"."
                return $OCF_SUCCESS
                ;;
            "shut down"|"shut down in recovery")
                # The instance should be stopped.
                # We don't care if it was Primary or Secondary before, because
                # we always start instances as Secondaries, and then promotes
                # if necessary.
                ocf_log debug "$__OCF_ACTION - _controldata: instance $OCF_RESOURCE_INSTANCE state is \"$inststate\"."
                return $OCF_NOT_RUNNING
                ;;
            *)
                # The state is "in crash recovery", "starting up" or 
                # "shutting down".
                # This state should be transitional, so we wait and loop to 
                # check if it changes.
                ocf_log debug "$__OCF_ACTION - _controldata: instance $OCF_RESOURCE_INSTANCE state is \"$inststate\": waiting."
                sleep 1
                inststate=$($CMD)
                ;;
        esac
    done

    # If we reach this point, something went wrong with pg_controldata
    # FIXME: better to raise a hard error at this point, like OCF_ERR_CONFIGURED ?
    ocf_log error "$__OCF_ACTION - _controldata: unable get instance $OCF_RESOURCE_INSTANCE state using pg_controldata."
    ocf_log debug "$__OCF_ACTION - _controldata: instance $OCF_RESOURCE_INSTANCE state is \"$instance_state\"."
    return $OCF_ERR_GENERIC

}

# Run a query using psql
#
_query() {
    local rc
    local ANS
    local QUERY="$1"

    ANS=$(runuser "${OCF_RESKEY_system_user}" -l -c "
psql -XAt --set='ON_ERROR_STOP=1' -p ${OCF_RESKEY_pgport} postgres <<EOQ
$QUERY
EOQ
")
    rc=$?

    echo "$ANS"

    # possible error codes:
    #   1: failed to get resources (memory, missing file, ...)
    #   2: unable to connect
    #   3: query failed
    return $rc
}

# Checks to confirm if the instance is really started if _pg_isready returned
# it should be the case, and to identify whether the instance is Primary or 
# Secondary
#
_confirm_started() {
    local is_in_recovery
    local query_rc
    local controldata_rc

    if [ $OCF_CHECK_LEVEL -ge 10 ]; then
        # Medium check, call psql and pg_is_in_recovery()
        is_in_recovery=$(_query "SELECT pg_is_in_recovery()")
        query_rc=$?

        if [ $query_rc -eq 0 ]; then
            # The query was executed, check the result
            if [ "$is_in_recovery" = "t" ]; then
                # The instance is a Secondary.
                return $OCF_SUCCESS
            elif [ "$is_in_recovery" = "f" ]; then
                # The instance is a Primary.
                return $OCF_RUNNING_MASTER
            else
                # This should not happen, raise a hard configuration error.
                return $OCF_ERR_CONFIGURED
            fi
        elif [ $query_rc -eq 1 -o $query_rc -eq 2 ]; then
            # psql cound not connect to the instance
            # FIXME raise an hard error here ?
            return $OCF_ERR_GENERIC
        elif [ $query_rc -eq 3 ]; then
            # The query failed.
            # This should not happen, raise a hard configuration error.
            return $OCF_ERR_CONFIGURED
        fi
    fi
    # Soft check, call pg_controldata to check wether Primary or Secondary
    _controldata
    controldata_rc=$?
    if [ $controldata_rc -eq $OCF_NOT_RUNNING ]; then
        # Something went wrong, the instance should not listening if not
        # running !
        # FIXME raise an hard error here ?
        return $OCF_ERR_GENERIC
    fi
    # return the state of the running instance
    return $controldata_rc

}

# Checks to confirm if the instance is really stopped if _pg_isready returned
# it should be the case, and if it was propertly shut down.
#
_confirm_stopped() {
    local pgctlstatus_rc
    local controldata_rc

    _pg_ctl_status
    pgctlstatus_rc=$?

    if [ $pgctlstatus_rc -eq 0 ]; then
        # The pid file exists and the process is available
        # That should not be the case, return an error
        # FIXME raise an hard error at this point ?
        return $OCF_ERR_GENERIC
    else
        # The pid file does not exists or the process is not available
        # We're good, continue the check with pg_controldata
        _controldata
        controldata_rc=$?
        if [ $controldata_rc -eq $OCF_RUNNING_MASTER ]; then
            # The controldata has not been updated to "shutdown"
            # It should mean we had a crash on a Primary instance
            return $OCF_FAILED_MASTER
        elif [ $controldata_rc -eq $OCF_SUCCESS ]; then
            # The controldata has not been updated to "shutdown in recovery"
            # It should mean we had a crash on a Secondary instance
            # There is no "FAILED_SLAVE" return code, so we return a 
            # generic error
            return $OCF_ERR_GENERIC
        elif [ $controldata_rc -eq $OCF_NOT_RUNNING ]; then
            # The controldata state is consistent, the instance was
            # probably propertly shut down.
            return $OCF_NOT_RUNNING
        else
            # Something went wrong with the controldata check.
            return $controldata_rc
        fi
    fi

}

# Start the PostgreSQL instance as a *slave*
pg_start() {
    local rc
    OCF_CHECK_LEVEL=20

    # instance must be running as slave or being stopped
    # anything else is an error
    pg_monitor
    rc=$?
    if [ $rc -eq $OCF_SUCCESS ]; then
        ocf_log info "$__OCF_ACTION - pg_start: instance $OCF_RESOURCE_INSTANCE already started."
        return $OCF_SUCCESS
    elif [ $rc -ne $OCF_NOT_RUNNING ] ; then
        ocf_log error "$__OCF_ACTION - pg_start: unexpected state for instance $OCF_RESOURCE_INSTANCE (returned $rc)."
        return $OCF_ERR_GENERIC
    fi

    #
    # From here, the instance is NOT running for sure
    #

    # create the recovery.conf file to start as a standby
    # NOTE: the recovery.conf is supposed to be set up so the standby can
    # connect to the instance in production. As there is no instance in
    # production on start, standbys will bail about failing to connect to
    # the primary.
    # As we can not reload a recovery.conf file on a standby without restarting
    # it, we will leave with this.
    cp -f "${OCF_RESKEY_recovery_template}" "${OCF_RESKEY_pgdata}/recovery.conf" &> /dev/null
    rc=$?

    if [ $rc -ne 0 ]; then
        return $OCF_ERR_GENERIC
    fi

    runuser -l "${OCF_RESKEY_system_user}" -c "${OCF_RESKEY_bindir}/pg_ctl -D ${OCF_RESKEY_pgdata} -w start"
    rc=$?

    # wait for the start to finish
    if [ $rc -eq 0 ]; then
        pg_monitor
        rc=$?
        while [ $rc -eq $OCF_NOT_RUNNING ]
        do
            sleep 1
            pg_monitor
            rc=$?
        done

        if [ $rc -eq $OCF_SUCCESS ]; then
            ocf_log info  "$__OCF_ACTION - pg_start: instance $OCF_RESOURCE_INSTANCE started."
        else
            ocf_log error "$__OCF_ACTION - pg_start: instance $OCF_RESOURCE_INSTANCE is not running as a slave (returned $rc)."
        fi

        return $rc
    fi

    ocf_log error "$__OCF_ACTION - pg_start: instance $OCF_RESOURCE_INSTANCE failed to start."
    return $OCF_ERR_GENERIC
}

# Stop the PostgreSQL instance
pg_stop() {
    local rc
    OCF_CHECK_LEVEL=20

    # instance must be running as slave or master or being stopped
    # anything else is an error
    pg_monitor
    rc=$?
    if [ $rc -eq $OCF_NOT_RUNNING ] ; then
        ocf_log info "$__OCF_ACTION - pg_stop: instance $OCF_RESOURCE_INSTANCE already stopped."
        return $OCF_SUCCESS
    elif [ $rc -ne $OCF_SUCCESS -a $rc -ne $OCF_RUNNING_MASTER ]; then
        ocf_log warn "$__OCF_ACTION - pg_stop: unexpected state for instance $OCF_RESOURCE_INSTANCE (returned $rc)."
    fi

    #
    # From here, the instance is running for sure
    #

    # try to quit with proper shutdown
    #FIXME we should add a timeout in pg_ctl call, and try an immediate stop 
    # after that
    runuser -l "${OCF_RESKEY_system_user}" -c "${OCF_RESKEY_bindir}/pg_ctl -D ${OCF_RESKEY_pgdata} -w -m fast stop"
    rc=$?

    # wait for the stop to finish
    if [ $rc -eq 0 ]; then
        pg_monitor
        rc=$?
        while [ $rc -ne $OCF_NOT_RUNNING ]
        do
        #FIXME if proper shutdown does not cut it we need to use immediate stop
        # after some time, and avoid FAILED pacemaker state, which would 
        # trigger fencing
            sleep 1
            pg_monitor
            rc=$?
        done

        ocf_log info  "$__OCF_ACTION - pg_stop: instance $OCF_RESOURCE_INSTANCE stopped."
        return $rc
    fi

    ocf_log error "$__OCF_ACTION - pg_stop: instance $OCF_RESOURCE_INSTANCE failed to stop."
    return $OCF_ERR_GENERIC

}

# Promote the standby instance to production 
pg_promote() {

}

# Monitor the PostgreSQL instance
pg_monitor() {
    local rc
    local pgisready_rc
    local controldata_rc

    # First check, verify if the instance is listening
    _pg_isready
    pgisready_rc=$?

    if [ $pgisready_rc -eq 0 ]; then
        # The instance is listening
        _confirm_started
        return $?

    elif [ $pgisready_rc -eq 1 ]; then
        # The attempt was rejected.
        # This could happen in several cases:
        #   - at startup
        #   - during shutdown
        #   - during crash recovery
        #   - if instance is a warm standby
        # Try to confirm using pg_controldata
        _controldata
        controldata_rc=$?
        if [ $controldata_rc -eq $OCF_RUNNING_MASTER -o $controldata_rc -eq $OCF_SUCESS]; then
            # This state indicates that pg_isready check should succeed
            # We check again
            _pg_isready
            pgisready_rc=$?
            if [ $pgisready_rc -eq 0 ]; then
                # Consistent with pg_controdata output
                # We can check if the instance is Primary or Secondary
                _confirm_started
                return $?

            else
                # Still not consistent, raise an error.
                # FIXME raise an hard error here ?
                return $OCF_ERR_GENERIC
            fi

        elif [ $controldata_rc -eq $OCF_NOT_RUNNING ]; then
            # This state indicates that pg_isready check should fail with rc 2
            # We check again
            _pg_isready
            pgisready_rc=$?
            if [ $pgisready_rc -eq 2 ]; then
                # Consistent with pg_controdata output
                # We can check the process status.
                _confirm_stopped
                return $?

            else
                # Still not consistent, raise an error.
                # FIXME raise an hard error here ?
                return $OCF_ERR_GENERIC
            fi

        else
            # Something went wrong with the controldata check.
            return $controldata_rc
        fi


    elif [ $pgisready_rc -eq 2 ]; then
        # The instance is not listening
        # Check instance process status
        _confirm_stopped
        return $?

    elif [ $pgisready_rc -eq 3 ]; then
        # No attempt was done, probably a syntax error
        # Hard configuration error, we don't want to retry or failover here
        ocf_log error "$__OCF_ACTION - pg_monitor(_pg_isready): unknown error while checking instance $OCF_RESOURCE_INSTANCE state !"
        return $OCF_ERR_CONFIGURED
    fi

    ocf_log error "$__OCF_ACTION - pg_monitor: unexpected result when checking instance $OCF_RESOURCE_INSTANCE status."
    return $OCF_ERR_GENERIC
}

# Demote the PostgreSQL from production to standby
# To demote a PostgreSQL instance, we must:
#   * stop it gracefully
#   * create recovery.conf with standby_mode = on
#   * start it
pg_demote() {
    local rc

    pg_monitor
    rc=$?
    case "$rc" in
        "$OCF_RUNNING_MASTER") # Running as master. Normal, expected behavior.
            ocf_log debug "$__OCF_ACTION - pg_demote: currently running as a primary."
            ;;
        "$OCF_SUCCESS") # Alread running as slave. Nothing to do.
            ocf_log debug "$__OCF_ACTION - pg_demote: currently running as a standby."
            return $OCF_SUCCESS
            ;;
        "$OCF_NOT_RUNNING") # Currently not running. This state is unexpected.
            ocf_log error "$__OCF_ACTION - pg_demote: currently not running."
            return $OCF_ERR_GENERIC
            ;;
        *) # Failed resource. Let the cluster manager recover.
            ocf_log error "$__OCF_ACTION - pg_demote: unexpected error, cannot demote."
            return $rc
            ;;
    esac

    # WARNING: the instance **MUST** be stopped gracefully. Do **not** use
    # pg_stop() or service or systemctl here as these commands might force-stop
    # the PostgreSQL instance using immediate after some timeout and return
    # success, which is misleading.
    runuser -l "${OCF_RESKEY_system_user}" -c "${OCF_RESKEY_bindir}/pg_ctl -D ${OCF_RESKEY_pgdata} -w stop"
    rc=$?

    # no need to wait for stop to complete, this is handled in pg_ctl using -w
    if [ $? -ne 0 ]; then
        ocf_log error "$__OCF_ACTION - pg_demote: failed to stop $OCF_RESOURCE_INSTANCE using pg_ctl (returned $rc)."
        return $OCF_ERR_GENERIC
    fi

    # Double check that the instance is stopped correctly
    # FIXME: Ask for a higher OCF_CHECK_LEVEL ?
    pg_monitor
    rc=$?
    if [ $? -ne $OCF_NOT_RUNNING ]; then
        ocf_log error "$__OCF_ACTION - pg_demote: unexpected $OCF_RESOURCE_INSTANCE state: monitor status ($rc) disagree with pg_ctl return code."
        return $OCF_ERR_GENERIC
    fi

    #
    # At this point, the instance must be stopped gracefully
    #

    # Note: We do not need to handle the recovery.conf file here as pg_start()
    # deal with that itself. Equally, no need to wait for the start to complete
    # here, handled in pg_start().
    pg_start
    rc=$?
    if [ $? -eq $OCF_SUCCESS ]; then
        ocf_log info "$__OCF_ACTION - pg_demote: $OCF_RESOURCE_INSTANCE started as a standby."
        return $OCF_SUCCESS
    fi

    # NOTE: no need to double check the instance state as pg_start already use
    # pg_monitor to check the state before returning

    ocf_log error "$__OCF_ACTION - pg_demote: starting $OCF_RESOURCE_INSTANCE as a standby failed (returned $rc)."
    return $OCF_ERR_GENERIC
}

# Called on pre and post actions.
pg_notify() {

}


# Validate everything is fine before running the actions
case $1 in
    start|stop|reload|monitor|promote|demote|notify)
        pgsql_validate_all || exit $? ;;
    # no need to validate for meta-data, methods or validate-all
esac


# Run action
case $1 in
    start)
        pg_start
        exit $?;;
    stop) ;;
    monitor)
        pg_monitor
        exit $?;;
    promote) ;;
    demote) ;;
    notify) ;;
    meta-data)
        ocf_meta_data
        exit 0
        ;;
    methods)
        ocf_methods
        exit 0
        ;;
    validate-all)
        pgsql_validate_all
        exit $?
        ;;
    *)
        exit $OCF_ERR_UNIMPLEMENTED
        ;;
esac
